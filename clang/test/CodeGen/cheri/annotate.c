// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %cheri_purecap_cc1 -o - -emit-llvm -O0 %s | FileCheck %s
// RUN: %cheri_cc1 -o - -emit-llvm -O0 %s | FileCheck %s -check-prefix HYBRID

// Ensure that the embedded source paths match across all build machines:
#line 6 "/some/dir/annotate.c"

// CHECK-LABEL: @annotated_function(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
// HYBRID-LABEL: @annotated_function(
// HYBRID-NEXT:  entry:
// HYBRID-NEXT:    ret void
//
void annotated_function(void) __attribute__((annotate("function"))) {}

int annotated_global __attribute__((annotate("global"))) = 1;

/// Check that globals annotations are emitted in AS200 for purecap:

// CHECK-LABEL: @var_annotation(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[B:%.*]] = alloca i32, align 4, addrspace(200)
// CHECK-NEXT:    call void @llvm.var.annotation.p200(ptr addrspace(200) [[B]], ptr addrspace(200) @.str.3, ptr addrspace(200) @.str.1, i32 34, ptr addrspace(200) null)
// CHECK-NEXT:    ret void
//
// HYBRID-LABEL: @var_annotation(
// HYBRID-NEXT:  entry:
// HYBRID-NEXT:    [[B:%.*]] = alloca i32, align 4
// HYBRID-NEXT:    call void @llvm.var.annotation.p0(ptr [[B]], ptr @.str.3, ptr @.str.1, i32 34, ptr null)
// HYBRID-NEXT:    ret void
//
void var_annotation(void) {
  __attribute__((annotate("foo"))) int b;
}

// Should be overloaded and args in AS200

// CHECK-LABEL: @ptr_annotation(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[VAR:%.*]] = alloca [[STRUCT_ANON:%.*]], align 4, addrspace(200)
// CHECK-NEXT:    [[U:%.*]] = getelementptr inbounds [[STRUCT_ANON]], ptr addrspace(200) [[VAR]], i32 0, i32 0
// CHECK-NEXT:    store i32 0, ptr addrspace(200) [[U]], align 4
// CHECK-NEXT:    [[V:%.*]] = getelementptr inbounds [[STRUCT_ANON]], ptr addrspace(200) [[VAR]], i32 0, i32 1
// CHECK-NEXT:    [[TMP0:%.*]] = call ptr addrspace(200) @llvm.ptr.annotation.p200.p200(ptr addrspace(200) [[V]], ptr addrspace(200) @.str.4, ptr addrspace(200) @.str.1, i32 62, ptr addrspace(200) null)
// CHECK-NEXT:    store i32 0, ptr addrspace(200) [[TMP0]], align 4
// CHECK-NEXT:    ret i32 0
//
// HYBRID-LABEL: @ptr_annotation(
// HYBRID-NEXT:  entry:
// HYBRID-NEXT:    [[VAR:%.*]] = alloca [[STRUCT_ANON:%.*]], align 4
// HYBRID-NEXT:    [[U:%.*]] = getelementptr inbounds [[STRUCT_ANON]], ptr [[VAR]], i32 0, i32 0
// HYBRID-NEXT:    store i32 0, ptr [[U]], align 4
// HYBRID-NEXT:    [[V:%.*]] = getelementptr inbounds [[STRUCT_ANON]], ptr [[VAR]], i32 0, i32 1
// HYBRID-NEXT:    [[TMP0:%.*]] = call ptr @llvm.ptr.annotation.p0.p0(ptr [[V]], ptr @.str.4, ptr @.str.1, i32 62, ptr null)
// HYBRID-NEXT:    store i32 0, ptr [[TMP0]], align 4
// HYBRID-NEXT:    ret i32 0
//
int ptr_annotation(void) {
  struct {
    int u;
    __attribute__((annotate("myannotation"))) int v;
  } var;
  var.u = 0;
  var.v = 0;
  return (0);
}

// Should be overloaded and args in AS200

// CHECK-LABEL: @builtin_annotation(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[X_ADDR:%.*]] = alloca i64, align 8, addrspace(200)
// CHECK-NEXT:    [[Y:%.*]] = alloca i64, align 8, addrspace(200)
// CHECK-NEXT:    store i64 [[X:%.*]], ptr addrspace(200) [[X_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load i64, ptr addrspace(200) [[X_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = call i64 @llvm.annotation.i64.p200(i64 [[TMP0]], ptr addrspace(200) @.str.5, ptr addrspace(200) @.str.1, i32 100)
// CHECK-NEXT:    store i64 [[TMP1]], ptr addrspace(200) [[Y]], align 8
// CHECK-NEXT:    [[TMP2:%.*]] = load i64, ptr addrspace(200) [[X_ADDR]], align 8
// CHECK-NEXT:    [[TMP3:%.*]] = load i64, ptr addrspace(200) [[Y]], align 8
// CHECK-NEXT:    [[ADD:%.*]] = add nsw i64 [[TMP2]], [[TMP3]]
// CHECK-NEXT:    [[CONV:%.*]] = trunc i64 [[ADD]] to i32
// CHECK-NEXT:    ret i32 [[CONV]]
//
// HYBRID-LABEL: @builtin_annotation(
// HYBRID-NEXT:  entry:
// HYBRID-NEXT:    [[X_ADDR:%.*]] = alloca i64, align 8
// HYBRID-NEXT:    [[Y:%.*]] = alloca i64, align 8
// HYBRID-NEXT:    store i64 [[X:%.*]], ptr [[X_ADDR]], align 8
// HYBRID-NEXT:    [[TMP0:%.*]] = load i64, ptr [[X_ADDR]], align 8
// HYBRID-NEXT:    [[TMP1:%.*]] = call i64 @llvm.annotation.i64.p0(i64 [[TMP0]], ptr @.str.5, ptr @.str.1, i32 100)
// HYBRID-NEXT:    store i64 [[TMP1]], ptr [[Y]], align 8
// HYBRID-NEXT:    [[TMP2:%.*]] = load i64, ptr [[X_ADDR]], align 8
// HYBRID-NEXT:    [[TMP3:%.*]] = load i64, ptr [[Y]], align 8
// HYBRID-NEXT:    [[ADD:%.*]] = add nsw i64 [[TMP2]], [[TMP3]]
// HYBRID-NEXT:    [[CONV:%.*]] = trunc i64 [[ADD]] to i32
// HYBRID-NEXT:    ret i32 [[CONV]]
//
int builtin_annotation(long x) {
  long y = __builtin_annotation(x, "annotation_a");
  return x + y;
}

// Should be overloaded and args in AS200

// https://github.com/CTSRD-CHERI/llvm-project/issues/327
// CHECK-LABEL: @issue327(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[VAR:%.*]] = alloca [[STRUCT_ANON_0:%.*]], align 4, addrspace(200)
// CHECK-NEXT:    [[X:%.*]] = alloca ptr addrspace(200), align 16, addrspace(200)
// CHECK-NEXT:    store ptr addrspace(200) [[VAR]], ptr addrspace(200) [[X]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[X]], align 16
// CHECK-NEXT:    [[U:%.*]] = getelementptr inbounds [[STRUCT_ANON_0]], ptr addrspace(200) [[TMP0]], i32 0, i32 0
// CHECK-NEXT:    [[TMP1:%.*]] = call ptr addrspace(200) @llvm.ptr.annotation.p200.p200(ptr addrspace(200) [[U]], ptr addrspace(200) @.str.4, ptr addrspace(200) @.str.1, i32 140, ptr addrspace(200) null)
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr addrspace(200) [[TMP1]], align 4
// CHECK-NEXT:    [[TMP3:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[X]], align 16
// CHECK-NEXT:    [[U1:%.*]] = getelementptr inbounds [[STRUCT_ANON_0]], ptr addrspace(200) [[TMP3]], i32 0, i32 0
// CHECK-NEXT:    [[TMP4:%.*]] = call ptr addrspace(200) @llvm.ptr.annotation.p200.p200(ptr addrspace(200) [[U1]], ptr addrspace(200) @.str.4, ptr addrspace(200) @.str.1, i32 140, ptr addrspace(200) null)
// CHECK-NEXT:    store i32 [[TMP2]], ptr addrspace(200) [[TMP4]], align 4
// CHECK-NEXT:    ret void
//
// HYBRID-LABEL: @issue327(
// HYBRID-NEXT:  entry:
// HYBRID-NEXT:    [[VAR:%.*]] = alloca [[STRUCT_ANON_0:%.*]], align 4
// HYBRID-NEXT:    [[X:%.*]] = alloca ptr addrspace(200), align 16
// HYBRID-NEXT:    [[VAR_ASCAST:%.*]] = addrspacecast ptr [[VAR]] to ptr addrspace(200)
// HYBRID-NEXT:    store ptr addrspace(200) [[VAR_ASCAST]], ptr [[X]], align 16
// HYBRID-NEXT:    [[TMP0:%.*]] = load ptr addrspace(200), ptr [[X]], align 16
// HYBRID-NEXT:    [[U:%.*]] = getelementptr inbounds [[STRUCT_ANON_0]], ptr addrspace(200) [[TMP0]], i32 0, i32 0
// HYBRID-NEXT:    [[TMP1:%.*]] = call ptr addrspace(200) @llvm.ptr.annotation.p200.p0(ptr addrspace(200) [[U]], ptr @.str.4, ptr @.str.1, i32 140, ptr null)
// HYBRID-NEXT:    [[TMP2:%.*]] = load i32, ptr addrspace(200) [[TMP1]], align 4
// HYBRID-NEXT:    [[TMP3:%.*]] = load ptr addrspace(200), ptr [[X]], align 16
// HYBRID-NEXT:    [[U1:%.*]] = getelementptr inbounds [[STRUCT_ANON_0]], ptr addrspace(200) [[TMP3]], i32 0, i32 0
// HYBRID-NEXT:    [[TMP4:%.*]] = call ptr addrspace(200) @llvm.ptr.annotation.p200.p0(ptr addrspace(200) [[U1]], ptr @.str.4, ptr @.str.1, i32 140, ptr null)
// HYBRID-NEXT:    store i32 [[TMP2]], ptr addrspace(200) [[TMP4]], align 4
// HYBRID-NEXT:    ret void
//
void issue327(void) {
  struct {
    __attribute__((annotate("myannotation"))) int u;
  } var, *__capability x;
  x = &var;
  x->u = x->u;
}



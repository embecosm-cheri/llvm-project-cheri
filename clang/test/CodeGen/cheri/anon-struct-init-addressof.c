// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature
/// Check that we generate valid IR for a `&(struct foo){ ... }` expression
// RUN: %cheri_purecap_cc1 %s -O0 -o - -emit-llvm | %cheri_FileCheck %s -check-prefixes CHECK

typedef unsigned u_int;
typedef unsigned pid_t;

struct procctl_reaper_pidinfo {
  pid_t pi_pid;
  pid_t pi_subtree;
  u_int pi_flags;
  u_int pi_pad0[15];
};

struct procctl_reaper_pids {
  u_int rp_count;
  u_int rp_pad0[15];
  struct procctl_reaper_pidinfo *rp_pids;
};

typedef int idtype_t;
#define P_PID 0
#define PROC_REAP_GETPIDS 22

extern int procctl(idtype_t, pid_t, int, void *);

// CHECK-LABEL: define {{[^@]+}}@test
// CHECK-SAME: (i32 noundef signext [[PARENT:%.*]]) addrspace(200) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[PARENT_ADDR:%.*]] = alloca i32, align 4, addrspace(200)
// CHECK-NEXT:    [[INFO:%.*]] = alloca [10 x %struct.procctl_reaper_pidinfo], align 4, addrspace(200)
// CHECK-NEXT:    [[R:%.*]] = alloca i32, align 4, addrspace(200)
// CHECK-NEXT:    [[DOTCOMPOUNDLITERAL:%.*]] = alloca [[STRUCT_PROCCTL_REAPER_PIDS:%.*]], align 16, addrspace(200)
// CHECK-NEXT:    store i32 [[PARENT]], ptr addrspace(200) [[PARENT_ADDR]], align 4
// CHECK-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [10 x %struct.procctl_reaper_pidinfo], ptr addrspace(200) [[INFO]], i64 0, i64 0
// CHECK-NEXT:    call void @llvm.memset.p200.i64(ptr addrspace(200) align 4 [[ARRAYDECAY]], i8 0, i64 720, i1 false)
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr addrspace(200) [[PARENT_ADDR]], align 4
// CHECK-NEXT:    call void @llvm.memset.p200.i64(ptr addrspace(200) align 16 [[DOTCOMPOUNDLITERAL]], i8 0, i64 80, i1 false)
// CHECK-NEXT:    [[RP_COUNT:%.*]] = getelementptr inbounds [[STRUCT_PROCCTL_REAPER_PIDS]], ptr addrspace(200) [[DOTCOMPOUNDLITERAL]], i32 0, i32 0
// CHECK-NEXT:    store i32 10, ptr addrspace(200) [[RP_COUNT]], align 16
// CHECK-NEXT:    [[RP_PIDS:%.*]] = getelementptr inbounds [[STRUCT_PROCCTL_REAPER_PIDS]], ptr addrspace(200) [[DOTCOMPOUNDLITERAL]], i32 0, i32 2
// CHECK-NEXT:    [[ARRAYDECAY1:%.*]] = getelementptr inbounds [10 x %struct.procctl_reaper_pidinfo], ptr addrspace(200) [[INFO]], i64 0, i64 0
// CHECK-NEXT:    store ptr addrspace(200) [[ARRAYDECAY1]], ptr addrspace(200) [[RP_PIDS]], align 16
// CHECK-NEXT:    [[CALL:%.*]] = call signext i32 @procctl(i32 noundef signext 0, i32 noundef signext [[TMP0]], i32 noundef signext 22, ptr addrspace(200) noundef [[DOTCOMPOUNDLITERAL]])
// CHECK-NEXT:    store i32 [[CALL]], ptr addrspace(200) [[R]], align 4
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr addrspace(200) [[R]], align 4
// CHECK-NEXT:    ret i32 [[TMP1]]
//
int test(pid_t parent) {
  struct procctl_reaper_pidinfo info[10];
  __builtin_memset(info, '\0', sizeof(info));
  int r = procctl(P_PID, parent, PROC_REAP_GETPIDS,
                  &(struct procctl_reaper_pids){
                      .rp_count = sizeof(info) / sizeof(info[0]),
                      .rp_pids = info});
  return r;
}

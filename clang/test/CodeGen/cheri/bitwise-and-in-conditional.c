// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
/// In offset mode we should warn about the bitwise operations
// RUN: %cheri_purecap_cc1 -o - -cheri-uintcap=offset -O3 -emit-llvm %s -verify | %cheri_FileCheck '-D$UINTCAP_INTRIN=offset' %s -check-prefixes BROKEN-OPT
/// No need to warn in address mode since the comparision instructions
// RUN: %cheri_purecap_cc1 -o - -cheri-uintcap=addr -O3 -emit-llvm %s -verify=addr-non-exact | %cheri_FileCheck %s '-D$UINTCAP_INTRIN=address' -check-prefixes BROKEN-OPT
// addr-non-exact-no-diagnostics
/// However, this is still a problem with exact equals
// RUN: %cheri_purecap_cc1 -o - -cheri-uintcap=addr -cheri-comparison=exact -O3 -emit-llvm %s -verify | %cheri_FileCheck %s '-D$UINTCAP_INTRIN=address' -check-prefixes BROKEN-OPT

// Now the checks with data-dependent provenance (this is ugly since it breaks the consistent semantic model but does fix this deadlock)
// RUN: %cheri_purecap_cc1 -o - -cheri-uintcap=offset -cheri-data-dependent-provenance -O0 -emit-llvm %s -verify | %cheri_FileCheck '-D$UINTCAP_INTRIN=offset' %s -check-prefixes WORKS
// RUN: %cheri_purecap_cc1 -o - -cheri-uintcap=offset -cheri-data-dependent-provenance -O3 -emit-llvm %s -verify | %cheri_FileCheck '-D$UINTCAP_INTRIN=offset' %s -check-prefixes WORKS-OPT
// RUN: %cheri_purecap_cc1 -o - -cheri-uintcap=addr -cheri-data-dependent-provenance -O0 -emit-llvm %s -verify=datadep-addr | %cheri_FileCheck '-D$UINTCAP_INTRIN=address' %s -check-prefixes WORKS
// RUN: %cheri_purecap_cc1 -o - -cheri-uintcap=addr -cheri-data-dependent-provenance -O3 -emit-llvm %s -verify=datadep-addr | %cheri_FileCheck '-D$UINTCAP_INTRIN=address' %s -check-prefixes WORKS-OPT
// datadep-addr-no-diagnostics


void do_unlock(void);
__uintcap_t this_broke_qmutex(__uintcap_t mtx) {

  // This is a slightly adapted version of the code used in QMutexLocker():
  //    inline void unlock() Q_DECL_NOTHROW
  //    {
  //        if ((val & quintptr(1u)) == quintptr(1u)) {
  //            val &= ~quintptr(1u);
  //            mutex()->unlock();
  //        }
  //    }
  // By casting to uintptr_t Qt silences warnings but this causes an issue for the current CHERI C implementation:
  // The LHS of the equality comparision will be a capability derived from val, but with it's address/offset changed
  // to be anded with 1. Comparing this to a null-derived capability with offset 1 will always return false in the
  // offset interpretation and in the address interpretation it will also be always false if we enforce exact equals
  // instead of only comparing the vaddr.
  // The is no good fix for this since when checking if the low bit is set we want derivation from NULL, but when
  // then clearing the locked flag we do want to keep provenance. This means we can't have a consistent sematic model
  // without breaking one of the cases. The previous solution was to just always warn on bitwise-and but this is really
  // noisy and therefore will not be feasible if we want wide-spread adoption of CHERI for legacy codebases.
  //
  // By using a data-dependent provenance we can make this work for both cases:
  // - if the value is a small integer we derive from NULL (e.g. less than 1 page since those values should not be dereferenceable)
  // - otherwise we derive from the LHS and keep provenance
  //
  // This should not be a problem in most cases since the value will generally be a compile-time constant so the
  // LLVM optimizer can eliminate the select.
  if ((mtx & (__uintcap_t)1) == (__uintcap_t)1) { // locked flag is set
    // expected-warning@-1{{using bitwise and on a capability type may give surprising results}}
    mtx &= ~1;                                    // clear locked flag flag
    // expected-warning@-1{{using bitwise and on a capability type may give surprising results}}
    do_unlock();
  }
  return mtx;
}

//
//
//

// Same thing but not optimizable
// TODO: should we diagnose these cases where we actually emit a runtime check?
__uintcap_t can_fold_the_bitand_provenance_check(__uintcap_t mtx) {
  if ((mtx & (__uintcap_t)1) == (__uintcap_t)1) {
    // expected-warning@-1{{using bitwise and on a capability type may give surprising results}}
    mtx &= ~1;
    // expected-warning@-1{{using bitwise and on a capability type may give surprising results}}
    do_unlock();
  }
  return mtx;
}

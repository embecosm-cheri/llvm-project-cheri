// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature
// RUN: %riscv64_cheri_cc1 -std=c11 -o - -emit-llvm -disable-O0-optnone -Wno-atomic-alignment %s \
// RUN:   | opt -S -mem2reg | FileCheck --check-prefix=HYBRID %s
// RUN: %riscv64_cheri_purecap_cc1 -std=c11 -o - -emit-llvm -disable-O0-optnone -Wno-atomic-alignment %s \
// RUN:   | opt -S -mem2reg | FileCheck --check-prefix=PURECAP %s

// HYBRID-LABEL: define {{[^@]+}}@test_init
// HYBRID-SAME: (ptr noundef [[F:%.*]], i128 noundef [[VALUE:%.*]]) #[[ATTR0:[0-9]+]] {
// HYBRID-NEXT:  entry:
// HYBRID-NEXT:    store i128 [[VALUE]], ptr [[F]], align 16
// HYBRID-NEXT:    ret void
//
// PURECAP-LABEL: define {{[^@]+}}@test_init
// PURECAP-SAME: (ptr addrspace(200) noundef [[F:%.*]], i128 noundef [[VALUE:%.*]]) addrspace(200) #[[ATTR0:[0-9]+]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    store i128 [[VALUE]], ptr addrspace(200) [[F]], align 16
// PURECAP-NEXT:    ret void
//
void test_init(_Atomic(__uint128_t) *f, __uint128_t value) {
  __c11_atomic_init(f, value);
}

// HYBRID-LABEL: define {{[^@]+}}@test_load
// HYBRID-SAME: (ptr noundef [[F:%.*]]) #[[ATTR0]] {
// HYBRID-NEXT:  entry:
// HYBRID-NEXT:    [[ATOMIC_TEMP:%.*]] = alloca i128, align 16
// HYBRID-NEXT:    call void @__atomic_load(i64 noundef 16, ptr noundef [[F]], ptr noundef [[ATOMIC_TEMP]], i32 noundef signext 5)
// HYBRID-NEXT:    [[TMP0:%.*]] = load i128, ptr [[ATOMIC_TEMP]], align 16
// HYBRID-NEXT:    ret i128 [[TMP0]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_load
// PURECAP-SAME: (ptr addrspace(200) noundef [[F:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    [[ATOMIC_TEMP:%.*]] = alloca i128, align 16, addrspace(200)
// PURECAP-NEXT:    call void @__atomic_load(i64 noundef 16, ptr addrspace(200) noundef [[F]], ptr addrspace(200) noundef [[ATOMIC_TEMP]], i32 noundef signext 5)
// PURECAP-NEXT:    [[TMP0:%.*]] = load i128, ptr addrspace(200) [[ATOMIC_TEMP]], align 16
// PURECAP-NEXT:    ret i128 [[TMP0]]
//
__uint128_t test_load(_Atomic(__uint128_t) *f) {
  return __c11_atomic_load(f, __ATOMIC_SEQ_CST);
}

// HYBRID-LABEL: define {{[^@]+}}@test_store
// HYBRID-SAME: (ptr noundef [[F:%.*]], i128 noundef [[VALUE:%.*]]) #[[ATTR0]] {
// HYBRID-NEXT:  entry:
// HYBRID-NEXT:    [[DOTATOMICTMP:%.*]] = alloca i128, align 16
// HYBRID-NEXT:    store i128 [[VALUE]], ptr [[DOTATOMICTMP]], align 16
// HYBRID-NEXT:    call void @__atomic_store(i64 noundef 16, ptr noundef [[F]], ptr noundef [[DOTATOMICTMP]], i32 noundef signext 5)
// HYBRID-NEXT:    ret void
//
// PURECAP-LABEL: define {{[^@]+}}@test_store
// PURECAP-SAME: (ptr addrspace(200) noundef [[F:%.*]], i128 noundef [[VALUE:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    [[DOTATOMICTMP:%.*]] = alloca i128, align 16, addrspace(200)
// PURECAP-NEXT:    store i128 [[VALUE]], ptr addrspace(200) [[DOTATOMICTMP]], align 16
// PURECAP-NEXT:    call void @__atomic_store(i64 noundef 16, ptr addrspace(200) noundef [[F]], ptr addrspace(200) noundef [[DOTATOMICTMP]], i32 noundef signext 5)
// PURECAP-NEXT:    ret void
//
void test_store(_Atomic(__uint128_t) *f, __uint128_t value) {
  __c11_atomic_store(f, value, __ATOMIC_SEQ_CST);
}

// HYBRID-LABEL: define {{[^@]+}}@test_xchg
// HYBRID-SAME: (ptr noundef [[F:%.*]], i128 noundef [[VALUE:%.*]]) #[[ATTR0]] {
// HYBRID-NEXT:  entry:
// HYBRID-NEXT:    [[DOTATOMICTMP:%.*]] = alloca i128, align 16
// HYBRID-NEXT:    [[ATOMIC_TEMP:%.*]] = alloca i128, align 16
// HYBRID-NEXT:    store i128 [[VALUE]], ptr [[DOTATOMICTMP]], align 16
// HYBRID-NEXT:    call void @__atomic_exchange(i64 noundef 16, ptr noundef [[F]], ptr noundef [[DOTATOMICTMP]], ptr noundef [[ATOMIC_TEMP]], i32 noundef signext 5)
// HYBRID-NEXT:    [[TMP0:%.*]] = load i128, ptr [[ATOMIC_TEMP]], align 16
// HYBRID-NEXT:    ret i128 [[TMP0]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_xchg
// PURECAP-SAME: (ptr addrspace(200) noundef [[F:%.*]], i128 noundef [[VALUE:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    [[DOTATOMICTMP:%.*]] = alloca i128, align 16, addrspace(200)
// PURECAP-NEXT:    [[ATOMIC_TEMP:%.*]] = alloca i128, align 16, addrspace(200)
// PURECAP-NEXT:    store i128 [[VALUE]], ptr addrspace(200) [[DOTATOMICTMP]], align 16
// PURECAP-NEXT:    call void @__atomic_exchange(i64 noundef 16, ptr addrspace(200) noundef [[F]], ptr addrspace(200) noundef [[DOTATOMICTMP]], ptr addrspace(200) noundef [[ATOMIC_TEMP]], i32 noundef signext 5)
// PURECAP-NEXT:    [[TMP0:%.*]] = load i128, ptr addrspace(200) [[ATOMIC_TEMP]], align 16
// PURECAP-NEXT:    ret i128 [[TMP0]]
//
__uint128_t test_xchg(_Atomic(__uint128_t) *f, __uint128_t value) {
  return __c11_atomic_exchange(f, value, __ATOMIC_SEQ_CST);
}

// HYBRID-LABEL: define {{[^@]+}}@test_cmpxchg_weak
// HYBRID-SAME: (ptr noundef [[F:%.*]], ptr noundef [[EXP:%.*]], i128 noundef [[NEW:%.*]]) #[[ATTR0]] {
// HYBRID-NEXT:  entry:
// HYBRID-NEXT:    [[DOTATOMICTMP:%.*]] = alloca i128, align 16
// HYBRID-NEXT:    store i128 [[NEW]], ptr [[DOTATOMICTMP]], align 16
// HYBRID-NEXT:    [[CALL:%.*]] = call zeroext i1 @__atomic_compare_exchange(i64 noundef 16, ptr noundef [[F]], ptr noundef [[EXP]], ptr noundef [[DOTATOMICTMP]], i32 noundef signext 0, i32 noundef signext 0)
// HYBRID-NEXT:    ret i1 [[CALL]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_cmpxchg_weak
// PURECAP-SAME: (ptr addrspace(200) noundef [[F:%.*]], ptr addrspace(200) noundef [[EXP:%.*]], i128 noundef [[NEW:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    [[DOTATOMICTMP:%.*]] = alloca i128, align 16, addrspace(200)
// PURECAP-NEXT:    store i128 [[NEW]], ptr addrspace(200) [[DOTATOMICTMP]], align 16
// PURECAP-NEXT:    [[CALL:%.*]] = call zeroext i1 @__atomic_compare_exchange(i64 noundef 16, ptr addrspace(200) noundef [[F]], ptr addrspace(200) noundef [[EXP]], ptr addrspace(200) noundef [[DOTATOMICTMP]], i32 noundef signext 0, i32 noundef signext 0)
// PURECAP-NEXT:    ret i1 [[CALL]]
//
_Bool test_cmpxchg_weak(_Atomic(__uint128_t) *f, __uint128_t *exp, __uint128_t new) {
  return __c11_atomic_compare_exchange_weak(f, exp, new, __ATOMIC_RELAXED, __ATOMIC_RELAXED);
}

// HYBRID-LABEL: define {{[^@]+}}@test_cmpxchg_strong
// HYBRID-SAME: (ptr noundef [[F:%.*]], ptr noundef [[EXP:%.*]], i128 noundef [[NEW:%.*]]) #[[ATTR0]] {
// HYBRID-NEXT:  entry:
// HYBRID-NEXT:    [[DOTATOMICTMP:%.*]] = alloca i128, align 16
// HYBRID-NEXT:    store i128 [[NEW]], ptr [[DOTATOMICTMP]], align 16
// HYBRID-NEXT:    [[CALL:%.*]] = call zeroext i1 @__atomic_compare_exchange(i64 noundef 16, ptr noundef [[F]], ptr noundef [[EXP]], ptr noundef [[DOTATOMICTMP]], i32 noundef signext 0, i32 noundef signext 0)
// HYBRID-NEXT:    ret i1 [[CALL]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_cmpxchg_strong
// PURECAP-SAME: (ptr addrspace(200) noundef [[F:%.*]], ptr addrspace(200) noundef [[EXP:%.*]], i128 noundef [[NEW:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    [[DOTATOMICTMP:%.*]] = alloca i128, align 16, addrspace(200)
// PURECAP-NEXT:    store i128 [[NEW]], ptr addrspace(200) [[DOTATOMICTMP]], align 16
// PURECAP-NEXT:    [[CALL:%.*]] = call zeroext i1 @__atomic_compare_exchange(i64 noundef 16, ptr addrspace(200) noundef [[F]], ptr addrspace(200) noundef [[EXP]], ptr addrspace(200) noundef [[DOTATOMICTMP]], i32 noundef signext 0, i32 noundef signext 0)
// PURECAP-NEXT:    ret i1 [[CALL]]
//
_Bool test_cmpxchg_strong(_Atomic(__uint128_t) *f, __uint128_t *exp, __uint128_t new) {
  return __c11_atomic_compare_exchange_strong(f, exp, new, __ATOMIC_RELAXED, __ATOMIC_RELAXED);
}

// HYBRID-LABEL: define {{[^@]+}}@test_fetch_add
// HYBRID-SAME: (ptr noundef [[PTR:%.*]], i128 noundef [[VALUE:%.*]]) #[[ATTR0]] {
// HYBRID-NEXT:  entry:
// HYBRID-NEXT:    [[CALL:%.*]] = call i128 @__atomic_fetch_add_16(ptr noundef [[PTR]], i128 noundef [[VALUE]], i32 noundef signext 5)
// HYBRID-NEXT:    ret i128 [[CALL]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_fetch_add
// PURECAP-SAME: (ptr addrspace(200) noundef [[PTR:%.*]], i128 noundef [[VALUE:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    [[CALL:%.*]] = call i128 @__atomic_fetch_add_16(ptr addrspace(200) noundef [[PTR]], i128 noundef [[VALUE]], i32 noundef signext 5)
// PURECAP-NEXT:    ret i128 [[CALL]]
//
__uint128_t test_fetch_add(_Atomic(__uint128_t) *ptr, __uint128_t value) {
  return __c11_atomic_fetch_add(ptr, value, __ATOMIC_SEQ_CST);
}

// HYBRID-LABEL: define {{[^@]+}}@test_fetch_sub
// HYBRID-SAME: (ptr noundef [[PTR:%.*]], i128 noundef [[VALUE:%.*]]) #[[ATTR0]] {
// HYBRID-NEXT:  entry:
// HYBRID-NEXT:    [[CALL:%.*]] = call i128 @__atomic_fetch_sub_16(ptr noundef [[PTR]], i128 noundef [[VALUE]], i32 noundef signext 5)
// HYBRID-NEXT:    ret i128 [[CALL]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_fetch_sub
// PURECAP-SAME: (ptr addrspace(200) noundef [[PTR:%.*]], i128 noundef [[VALUE:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    [[CALL:%.*]] = call i128 @__atomic_fetch_sub_16(ptr addrspace(200) noundef [[PTR]], i128 noundef [[VALUE]], i32 noundef signext 5)
// PURECAP-NEXT:    ret i128 [[CALL]]
//
__uint128_t test_fetch_sub(_Atomic(__uint128_t) *ptr, __uint128_t value) {
  return __c11_atomic_fetch_sub(ptr, value, __ATOMIC_SEQ_CST);
}

// HYBRID-LABEL: define {{[^@]+}}@test_fetch_and
// HYBRID-SAME: (ptr noundef [[PTR:%.*]], i128 noundef [[VALUE:%.*]]) #[[ATTR0]] {
// HYBRID-NEXT:  entry:
// HYBRID-NEXT:    [[CALL:%.*]] = call i128 @__atomic_fetch_and_16(ptr noundef [[PTR]], i128 noundef [[VALUE]], i32 noundef signext 5)
// HYBRID-NEXT:    ret i128 [[CALL]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_fetch_and
// PURECAP-SAME: (ptr addrspace(200) noundef [[PTR:%.*]], i128 noundef [[VALUE:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    [[CALL:%.*]] = call i128 @__atomic_fetch_and_16(ptr addrspace(200) noundef [[PTR]], i128 noundef [[VALUE]], i32 noundef signext 5)
// PURECAP-NEXT:    ret i128 [[CALL]]
//
__uint128_t test_fetch_and(_Atomic(__uint128_t) *ptr, __uint128_t value) {
  return __c11_atomic_fetch_and(ptr, value, __ATOMIC_SEQ_CST);
}

// HYBRID-LABEL: define {{[^@]+}}@test_fetch_or
// HYBRID-SAME: (ptr noundef [[PTR:%.*]], i128 noundef [[VALUE:%.*]]) #[[ATTR0]] {
// HYBRID-NEXT:  entry:
// HYBRID-NEXT:    [[CALL:%.*]] = call i128 @__atomic_fetch_or_16(ptr noundef [[PTR]], i128 noundef [[VALUE]], i32 noundef signext 5)
// HYBRID-NEXT:    ret i128 [[CALL]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_fetch_or
// PURECAP-SAME: (ptr addrspace(200) noundef [[PTR:%.*]], i128 noundef [[VALUE:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    [[CALL:%.*]] = call i128 @__atomic_fetch_or_16(ptr addrspace(200) noundef [[PTR]], i128 noundef [[VALUE]], i32 noundef signext 5)
// PURECAP-NEXT:    ret i128 [[CALL]]
//
__uint128_t test_fetch_or(_Atomic(__uint128_t) *ptr, __uint128_t value) {
  return __c11_atomic_fetch_or(ptr, value, __ATOMIC_SEQ_CST);
}

// HYBRID-LABEL: define {{[^@]+}}@test_fetch_xor
// HYBRID-SAME: (ptr noundef [[PTR:%.*]], i128 noundef [[VALUE:%.*]]) #[[ATTR0]] {
// HYBRID-NEXT:  entry:
// HYBRID-NEXT:    [[CALL:%.*]] = call i128 @__atomic_fetch_xor_16(ptr noundef [[PTR]], i128 noundef [[VALUE]], i32 noundef signext 5)
// HYBRID-NEXT:    ret i128 [[CALL]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_fetch_xor
// PURECAP-SAME: (ptr addrspace(200) noundef [[PTR:%.*]], i128 noundef [[VALUE:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    [[CALL:%.*]] = call i128 @__atomic_fetch_xor_16(ptr addrspace(200) noundef [[PTR]], i128 noundef [[VALUE]], i32 noundef signext 5)
// PURECAP-NEXT:    ret i128 [[CALL]]
//
__uint128_t test_fetch_xor(_Atomic(__uint128_t) *ptr, __uint128_t value) {
  return __c11_atomic_fetch_xor(ptr, value, __ATOMIC_SEQ_CST);
}

// HYBRID-LABEL: define {{[^@]+}}@test_fetch_max
// HYBRID-SAME: (ptr noundef [[PTR:%.*]], i128 noundef [[VALUE:%.*]]) #[[ATTR0]] {
// HYBRID-NEXT:  entry:
// HYBRID-NEXT:    [[CALL:%.*]] = call i128 @__atomic_fetch_umax_16(ptr noundef [[PTR]], i128 noundef [[VALUE]], i32 noundef signext 5)
// HYBRID-NEXT:    ret i128 [[CALL]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_fetch_max
// PURECAP-SAME: (ptr addrspace(200) noundef [[PTR:%.*]], i128 noundef [[VALUE:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    [[CALL:%.*]] = call i128 @__atomic_fetch_umax_16(ptr addrspace(200) noundef [[PTR]], i128 noundef [[VALUE]], i32 noundef signext 5)
// PURECAP-NEXT:    ret i128 [[CALL]]
//
__uint128_t test_fetch_max(_Atomic(__uint128_t) *ptr, __uint128_t value) {
  return __c11_atomic_fetch_max(ptr, value, __ATOMIC_SEQ_CST);
}

// HYBRID-LABEL: define {{[^@]+}}@test_fetch_min
// HYBRID-SAME: (ptr noundef [[PTR:%.*]], i128 noundef [[VALUE:%.*]]) #[[ATTR0]] {
// HYBRID-NEXT:  entry:
// HYBRID-NEXT:    [[CALL:%.*]] = call i128 @__atomic_fetch_umin_16(ptr noundef [[PTR]], i128 noundef [[VALUE]], i32 noundef signext 5)
// HYBRID-NEXT:    ret i128 [[CALL]]
//
// PURECAP-LABEL: define {{[^@]+}}@test_fetch_min
// PURECAP-SAME: (ptr addrspace(200) noundef [[PTR:%.*]], i128 noundef [[VALUE:%.*]]) addrspace(200) #[[ATTR0]] {
// PURECAP-NEXT:  entry:
// PURECAP-NEXT:    [[CALL:%.*]] = call i128 @__atomic_fetch_umin_16(ptr addrspace(200) noundef [[PTR]], i128 noundef [[VALUE]], i32 noundef signext 5)
// PURECAP-NEXT:    ret i128 [[CALL]]
//
__uint128_t test_fetch_min(_Atomic(__uint128_t) *ptr, __uint128_t value) {
  return __c11_atomic_fetch_min(ptr, value, __ATOMIC_SEQ_CST);
}

// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature
// Previously compiling a recursive CCall would break the TBAA verifier because
// it was emitting a load of the whole struct instead of the individual elements
// RUN: %cheri_purecap_cc1 -no-struct-path-tbaa -emit-llvm -O2 -o - %s | FileCheck %s
// RUN: %cheri_purecap_cc1 -new-struct-path-tbaa -emit-llvm -O2 -o - %s | FileCheck %s
struct {
  void *a;
  void *b;
} c;
__attribute__((cheri_ccall)) __attribute__((cheri_method_class(c))) int
// CHECK-LABEL: define {{[^@]+}}@d
// CHECK-SAME: () local_unnamed_addr addrspace(200) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load i64, ptr addrspace(200) @__cheri_method.c.d, align 8, !invariant.load !2
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr addrspace(200), ptr addrspace(200) @c, align 16
// CHECK-NEXT:    [[TMP2:%.*]] = load ptr addrspace(200), ptr addrspace(200) getelementptr inbounds ([[STRUCT_ANON:%.*]], ptr addrspace(200) @c, i64 0, i32 1), align 16
// CHECK-NEXT:    [[CALL:%.*]] = tail call chericcallcc signext i32 @cheri_invoke(ptr addrspace(200) noundef [[TMP1]], ptr addrspace(200) noundef [[TMP2]], i64 noundef zeroext [[TMP0]]) #[[ATTR1:[0-9]+]]
// CHECK-NEXT:    ret i32 0
//
d(void) {
  d();
  return 0;
}

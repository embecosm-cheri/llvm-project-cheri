// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// REQUIRES: mips-registered-target
/// Check calling conventions for passing unions
// RUN: %cheri_purecap_cc1 %s -O0 -emit-llvm -o - | %cheri_FileCheck %s
// RUN: %cheri_purecap_cc1 %s -O2 -S -o - | %cheri_FileCheck %s -check-prefixes ASM

// example union from WebKit
union CallData {
  struct {
    char* c;
    int i;
  } Bar;
};

// example union that is passed into semctl()
union semun {
  int val;
  char *buf1;
  char *buf2;
  char *buf3;
};


// example of nested structs
union DeepDive {
  struct {
    struct {
      char* str;
    } B;
  } A;
};

union DeepNoDive {
  struct {
    struct {
      char* str;
      int d;
    } B;
  } A;
};

// CHECK-LABEL: @test_onelevel_helper(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[FOO:%.*]] = alloca [[UNION_CALLDATA:%.*]], align 16, addrspace(200)
// CHECK-NEXT:    [[TMP0:%.*]] = load [[UNION_CALLDATA]], ptr addrspace(200) [[FOO_COERCE:%.*]], align 16
// CHECK-NEXT:    store [[UNION_CALLDATA]] [[TMP0]], ptr addrspace(200) [[FOO]], align 16
// CHECK-NEXT:    ret void
//
void test_onelevel_helper(union CallData foo) {
}

// CHECK-LABEL: @test_onelevel(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[FOO:%.*]] = alloca [[UNION_CALLDATA:%.*]], align 16, addrspace(200)
// CHECK-NEXT:    [[C:%.*]] = getelementptr inbounds [[STRUCT_ANON:%.*]], ptr addrspace(200) [[FOO]], i32 0, i32 0
// CHECK-NEXT:    store ptr addrspace(200) @.str, ptr addrspace(200) [[C]], align 16
// CHECK-NEXT:    [[I:%.*]] = getelementptr inbounds [[STRUCT_ANON]], ptr addrspace(200) [[FOO]], i32 0, i32 1
// CHECK-NEXT:    store i32 9, ptr addrspace(200) [[I]], align 16
// CHECK-NEXT:    call void @test_onelevel_helper(ptr addrspace(200) inreg [[FOO]])
// CHECK-NEXT:    ret void
//
void test_onelevel() {
  union CallData foo;
  foo.Bar.c = "hello";
  foo.Bar.i = 9;
  test_onelevel_helper(foo);
}

// CHECK-LABEL: @test_zerolevels_helper(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[S:%.*]] = alloca [[UNION_SEMUN:%.*]], align 16, addrspace(200)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_SEMUN]], ptr addrspace(200) [[S]], i32 0, i32 0
// CHECK-NEXT:    store ptr addrspace(200) [[S_COERCE:%.*]], ptr addrspace(200) [[COERCE_DIVE]], align 16
// CHECK-NEXT:    ret void
//
void test_zerolevels_helper(union semun s) {
}

// CHECK-LABEL: @test_zerolevels(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[S:%.*]] = alloca [[UNION_SEMUN:%.*]], align 16, addrspace(200)
// CHECK-NEXT:    store ptr addrspace(200) @.str, ptr addrspace(200) [[S]], align 16
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_SEMUN]], ptr addrspace(200) [[S]], i32 0, i32 0
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[COERCE_DIVE]], align 16
// CHECK-NEXT:    call void @test_zerolevels_helper(ptr addrspace(200) inreg [[TMP0]])
// CHECK-NEXT:    ret void
//
void test_zerolevels() {
  union semun s;
  s.buf1 = "hello";
  test_zerolevels_helper(s);
}

// CHECK-LABEL: @test_twolevels_dive_helper(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[D:%.*]] = alloca [[UNION_DEEPDIVE:%.*]], align 16, addrspace(200)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_DEEPDIVE]], ptr addrspace(200) [[D]], i32 0, i32 0
// CHECK-NEXT:    [[COERCE_DIVE1:%.*]] = getelementptr inbounds [[STRUCT_ANON_0:%.*]], ptr addrspace(200) [[COERCE_DIVE]], i32 0, i32 0
// CHECK-NEXT:    [[COERCE_DIVE2:%.*]] = getelementptr inbounds [[STRUCT_ANON_1:%.*]], ptr addrspace(200) [[COERCE_DIVE1]], i32 0, i32 0
// CHECK-NEXT:    store ptr addrspace(200) [[D_COERCE:%.*]], ptr addrspace(200) [[COERCE_DIVE2]], align 16
// CHECK-NEXT:    ret void
//
void test_twolevels_dive_helper(union DeepDive d) {

}

// CHECK-LABEL: @test_twolevels_dive(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[D:%.*]] = alloca [[UNION_DEEPDIVE:%.*]], align 16, addrspace(200)
// CHECK-NEXT:    [[B:%.*]] = getelementptr inbounds [[STRUCT_ANON_0:%.*]], ptr addrspace(200) [[D]], i32 0, i32 0
// CHECK-NEXT:    [[STR:%.*]] = getelementptr inbounds [[STRUCT_ANON_1:%.*]], ptr addrspace(200) [[B]], i32 0, i32 0
// CHECK-NEXT:    store ptr addrspace(200) @.str, ptr addrspace(200) [[STR]], align 16
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_DEEPDIVE]], ptr addrspace(200) [[D]], i32 0, i32 0
// CHECK-NEXT:    [[COERCE_DIVE1:%.*]] = getelementptr inbounds [[STRUCT_ANON_0]], ptr addrspace(200) [[COERCE_DIVE]], i32 0, i32 0
// CHECK-NEXT:    [[COERCE_DIVE2:%.*]] = getelementptr inbounds [[STRUCT_ANON_1]], ptr addrspace(200) [[COERCE_DIVE1]], i32 0, i32 0
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[COERCE_DIVE2]], align 16
// CHECK-NEXT:    call void @test_twolevels_dive_helper(ptr addrspace(200) inreg [[TMP0]])
// CHECK-NEXT:    ret void
//
void test_twolevels_dive() {
  union DeepDive d;
  d.A.B.str = "hello";
  test_twolevels_dive_helper(d);
}

// CHECK-LABEL: @test_twolevels_nodive_helper(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[D:%.*]] = alloca [[UNION_DEEPNODIVE:%.*]], align 16, addrspace(200)
// CHECK-NEXT:    [[TMP0:%.*]] = load [[UNION_DEEPNODIVE]], ptr addrspace(200) [[D_COERCE:%.*]], align 16
// CHECK-NEXT:    store [[UNION_DEEPNODIVE]] [[TMP0]], ptr addrspace(200) [[D]], align 16
// CHECK-NEXT:    ret void
//
void test_twolevels_nodive_helper(union DeepNoDive d) {
}

// CHECK-LABEL: @test_twolevels_nodive(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[D:%.*]] = alloca [[UNION_DEEPNODIVE:%.*]], align 16, addrspace(200)
// CHECK-NEXT:    [[B:%.*]] = getelementptr inbounds [[STRUCT_ANON_2:%.*]], ptr addrspace(200) [[D]], i32 0, i32 0
// CHECK-NEXT:    [[STR:%.*]] = getelementptr inbounds [[STRUCT_ANON_3:%.*]], ptr addrspace(200) [[B]], i32 0, i32 0
// CHECK-NEXT:    store ptr addrspace(200) @.str, ptr addrspace(200) [[STR]], align 16
// CHECK-NEXT:    call void @test_twolevels_nodive_helper(ptr addrspace(200) inreg [[D]])
// CHECK-NEXT:    ret void
//
void test_twolevels_nodive() {
  union DeepNoDive d;
  d.A.B.str = "hello";
  test_twolevels_nodive_helper(d);
}

// Test that reading the values from semun works as expected
// Assembly tests shouldn't really be in clang but in this case we really want to verify that the calling convention matches

// For reading/writing the integer value we store the int and read back as capability/ write the cap and read back as an int
// TODO: could just use CIncOffset/CGetAddr here?

// CHECK-LABEL: @test_semun_read_int(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[S:%.*]] = alloca [[UNION_SEMUN:%.*]], align 16, addrspace(200)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_SEMUN]], ptr addrspace(200) [[S]], i32 0, i32 0
// CHECK-NEXT:    store ptr addrspace(200) [[S_COERCE:%.*]], ptr addrspace(200) [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr addrspace(200) [[S]], align 16
// CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP0]], 1
// CHECK-NEXT:    ret i32 [[ADD]]
//
int test_semun_read_int(union semun s) {
  return s.val + 1;
  // ASM-LABEL: test_semun_read_int:
  // ASM:      cincoffset	$c11, $c11, -[[#CAP_SIZE]]
  // ASM-NEXT: csc	$c3, $zero, 0($c11)
  // ASM-NEXT: clw	$1, $zero, 0($c11)
  // ASM-NEXT: addiu	$2, $1, 1
  // ASM-NEXT: cjr	$c17
  // ASM: .end test_semun_read_int
}

extern int semun_pass_int_helper(union semun s);
// CHECK-LABEL: @test_semun_pass_int(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[S:%.*]] = alloca [[UNION_SEMUN:%.*]], align 16, addrspace(200)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_SEMUN]], ptr addrspace(200) [[S]], i32 0, i32 0
// CHECK-NEXT:    store ptr addrspace(200) [[S_COERCE:%.*]], ptr addrspace(200) [[COERCE_DIVE]], align 16
// CHECK-NEXT:    store i32 1234, ptr addrspace(200) [[S]], align 16
// CHECK-NEXT:    [[COERCE_DIVE1:%.*]] = getelementptr inbounds [[UNION_SEMUN]], ptr addrspace(200) [[S]], i32 0, i32 0
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[COERCE_DIVE1]], align 16
// CHECK-NEXT:    [[CALL:%.*]] = call signext i32 @semun_pass_int_helper(ptr addrspace(200) inreg [[TMP0]])
// CHECK-NEXT:    ret i32 [[CALL]]
//
int test_semun_pass_int(union semun s) {
  s.val = 1234;
  // ASM-LABEL: test_semun_pass_int:
  // ASM:      csc	$c3, $zero, 0($c11)
  // ASM-NEXT: addiu	$1, $zero, 1234
  // ASM-NEXT: csw	$1, $zero, 0($c11)
  // ASM:      clc	$c3, $zero, 0($c11)
  // ASM-LABEL: .end test_semun_pass_int
  return semun_pass_int_helper(s);
}

// CHECK-LABEL: @test_semun_pass_int_2(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[DOTCOMPOUNDLITERAL:%.*]] = alloca [[UNION_SEMUN:%.*]], align 16, addrspace(200)
// CHECK-NEXT:    store i32 1234, ptr addrspace(200) [[DOTCOMPOUNDLITERAL]], align 16
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_SEMUN]], ptr addrspace(200) [[DOTCOMPOUNDLITERAL]], i32 0, i32 0
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[CALL:%.*]] = call signext i32 @semun_pass_int_helper(ptr addrspace(200) inreg [[TMP0]])
// CHECK-NEXT:    ret i32 [[CALL]]
//
int test_semun_pass_int_2() {
  // ASM-LABEL: test_semun_pass_int_2:
  // CHERI256 did a memset to zero before (this happens because clang thinks it
  // should do it for aggregates > 16)
  // TODO: do it for (> 16 || containsCaps)?
  // CHERI256:        csetbounds $c1, $c11, 32
  // CHERI256:        csc $cnull, $zero, 0($c1)
  // ASM:             addiu	$1, $zero, 1234
  // ASM-NEXT:        csw	$1, $zero, 0($c11)
  // ASM:             cjalr $c12, $c17
  // ASM-NEXT:        clc	$c3, $zero, 0($c11)
  // ASM-LABEL: .end test_semun_pass_int_2
  return semun_pass_int_helper((union semun){.val = 1234});
}

// CHECK-LABEL: @test_semun_read_cap(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[S:%.*]] = alloca [[UNION_SEMUN:%.*]], align 16, addrspace(200)
// CHECK-NEXT:    [[COERCE_DIVE:%.*]] = getelementptr inbounds [[UNION_SEMUN]], ptr addrspace(200) [[S]], i32 0, i32 0
// CHECK-NEXT:    store ptr addrspace(200) [[S_COERCE:%.*]], ptr addrspace(200) [[COERCE_DIVE]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[S]], align 16
// CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i8, ptr addrspace(200) [[TMP0]], i64 1
// CHECK-NEXT:    ret ptr addrspace(200) [[ADD_PTR]]
//
void* test_semun_read_cap(union semun s) {
  // ASM-LABEL: test_semun_read_cap:
  // ASM:      cjr $c17
  // ASM-NEXT: cincoffset	$c3, $c3, 1
  // ASM: .end test_semun_read_cap
  return s.buf1 + 1;
}

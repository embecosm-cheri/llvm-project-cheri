// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature
// RUN: %cheri_cc1 -o - -emit-llvm %s | FileCheck %s --check-prefixes=MIPS
// RUN: %riscv32_cheri_cc1 -o - -emit-llvm %s | FileCheck %s --check-prefixes=RV32IXCHERI
// RUN: %riscv64_cheri_cc1 -o - -emit-llvm %s | FileCheck %s --check-prefixes=RV64IXCHERI

// All of these types contain capabilities and thus should be passed indirectly
// for hybrid varargs.

struct single_cap {
  void * __capability cap;
};

struct double_cap {
  void * __capability cap1;
  void * __capability cap2;
};

struct single_cap_array {
  void * __capability cap[1];
};

struct double_cap_array {
  void * __capability cap[2];
};

struct mixed {
  int i;
  void * __capability cap;
};

union int_or_cap {
  int i;
  void * __capability cap;
};

extern void callee(long sel, ...);

extern void * __capability cap;
extern void * __capability uintcap;
extern struct single_cap single_cap;
extern struct double_cap double_cap;
extern struct single_cap_array single_cap_array;
extern struct double_cap_array double_cap_array;
extern struct mixed mixed;
extern union int_or_cap int_or_cap;

// MIPS-LABEL: define {{[^@]+}}@caller
// MIPS-SAME: () #[[ATTR0:[0-9]+]] {
// MIPS-NEXT:  entry:
// MIPS-NEXT:    [[NULL_CAP:%.*]] = alloca ptr addrspace(200), align 16
// MIPS-NEXT:    [[NULL_UINTCAP:%.*]] = alloca ptr addrspace(200), align 16
// MIPS-NEXT:    [[INDIRECT_ARG_TEMP:%.*]] = alloca ptr addrspace(200), align 16
// MIPS-NEXT:    [[INDIRECT_ARG_TEMP1:%.*]] = alloca ptr addrspace(200), align 16
// MIPS-NEXT:    [[INDIRECT_ARG_TEMP2:%.*]] = alloca ptr addrspace(200), align 16
// MIPS-NEXT:    [[INDIRECT_ARG_TEMP3:%.*]] = alloca ptr addrspace(200), align 16
// MIPS-NEXT:    [[BYVAL_TEMP:%.*]] = alloca [[STRUCT_SINGLE_CAP:%.*]], align 16
// MIPS-NEXT:    [[BYVAL_TEMP4:%.*]] = alloca [[STRUCT_DOUBLE_CAP:%.*]], align 16
// MIPS-NEXT:    [[BYVAL_TEMP5:%.*]] = alloca [[STRUCT_SINGLE_CAP_ARRAY:%.*]], align 16
// MIPS-NEXT:    [[BYVAL_TEMP6:%.*]] = alloca [[STRUCT_DOUBLE_CAP_ARRAY:%.*]], align 16
// MIPS-NEXT:    [[BYVAL_TEMP7:%.*]] = alloca [[STRUCT_MIXED:%.*]], align 16
// MIPS-NEXT:    [[BYVAL_TEMP8:%.*]] = alloca [[UNION_INT_OR_CAP:%.*]], align 16
// MIPS-NEXT:    store ptr addrspace(200) null, ptr [[NULL_CAP]], align 16
// MIPS-NEXT:    store ptr addrspace(200) null, ptr [[NULL_UINTCAP]], align 16
// MIPS-NEXT:    [[TMP0:%.*]] = load ptr addrspace(200), ptr [[NULL_CAP]], align 16
// MIPS-NEXT:    [[TMP1:%.*]] = load ptr addrspace(200), ptr [[NULL_UINTCAP]], align 16
// MIPS-NEXT:    [[TMP2:%.*]] = load ptr addrspace(200), ptr @cap, align 16
// MIPS-NEXT:    [[TMP3:%.*]] = load ptr addrspace(200), ptr @uintcap, align 16
// MIPS-NEXT:    store ptr addrspace(200) [[TMP0]], ptr [[INDIRECT_ARG_TEMP]], align 16
// MIPS-NEXT:    store ptr addrspace(200) [[TMP1]], ptr [[INDIRECT_ARG_TEMP1]], align 16
// MIPS-NEXT:    store ptr addrspace(200) [[TMP2]], ptr [[INDIRECT_ARG_TEMP2]], align 16
// MIPS-NEXT:    store ptr addrspace(200) [[TMP3]], ptr [[INDIRECT_ARG_TEMP3]], align 16
// MIPS-NEXT:    call void (i64, ...) @callee(i64 noundef signext 0, ptr noundef [[INDIRECT_ARG_TEMP]], ptr noundef [[INDIRECT_ARG_TEMP1]], ptr noundef [[INDIRECT_ARG_TEMP2]], ptr noundef [[INDIRECT_ARG_TEMP3]])
// MIPS-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[BYVAL_TEMP]], ptr align 16 @single_cap, i64 16, i1 false)
// MIPS-NEXT:    call void (i64, ...) @callee(i64 noundef signext 1, ptr noundef [[BYVAL_TEMP]])
// MIPS-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[BYVAL_TEMP4]], ptr align 16 @double_cap, i64 32, i1 false)
// MIPS-NEXT:    call void (i64, ...) @callee(i64 noundef signext 2, ptr noundef [[BYVAL_TEMP4]])
// MIPS-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[BYVAL_TEMP5]], ptr align 16 @single_cap_array, i64 16, i1 false)
// MIPS-NEXT:    call void (i64, ...) @callee(i64 noundef signext 3, ptr noundef [[BYVAL_TEMP5]])
// MIPS-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[BYVAL_TEMP6]], ptr align 16 @double_cap_array, i64 32, i1 false)
// MIPS-NEXT:    call void (i64, ...) @callee(i64 noundef signext 4, ptr noundef [[BYVAL_TEMP6]])
// MIPS-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[BYVAL_TEMP7]], ptr align 16 @mixed, i64 32, i1 false)
// MIPS-NEXT:    call void (i64, ...) @callee(i64 noundef signext 5, ptr noundef [[BYVAL_TEMP7]])
// MIPS-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[BYVAL_TEMP8]], ptr align 16 @int_or_cap, i64 16, i1 false)
// MIPS-NEXT:    call void (i64, ...) @callee(i64 noundef signext 6, ptr noundef [[BYVAL_TEMP8]])
// MIPS-NEXT:    ret void
//
// RV32IXCHERI-LABEL: define {{[^@]+}}@caller
// RV32IXCHERI-SAME: () #[[ATTR0:[0-9]+]] {
// RV32IXCHERI-NEXT:  entry:
// RV32IXCHERI-NEXT:    [[NULL_CAP:%.*]] = alloca ptr addrspace(200), align 8
// RV32IXCHERI-NEXT:    [[NULL_UINTCAP:%.*]] = alloca ptr addrspace(200), align 8
// RV32IXCHERI-NEXT:    [[INDIRECT_ARG_TEMP:%.*]] = alloca ptr addrspace(200), align 8
// RV32IXCHERI-NEXT:    [[INDIRECT_ARG_TEMP1:%.*]] = alloca ptr addrspace(200), align 8
// RV32IXCHERI-NEXT:    [[INDIRECT_ARG_TEMP2:%.*]] = alloca ptr addrspace(200), align 8
// RV32IXCHERI-NEXT:    [[INDIRECT_ARG_TEMP3:%.*]] = alloca ptr addrspace(200), align 8
// RV32IXCHERI-NEXT:    [[BYVAL_TEMP:%.*]] = alloca [[STRUCT_SINGLE_CAP:%.*]], align 8
// RV32IXCHERI-NEXT:    [[BYVAL_TEMP4:%.*]] = alloca [[STRUCT_DOUBLE_CAP:%.*]], align 8
// RV32IXCHERI-NEXT:    [[BYVAL_TEMP5:%.*]] = alloca [[STRUCT_SINGLE_CAP_ARRAY:%.*]], align 8
// RV32IXCHERI-NEXT:    [[BYVAL_TEMP6:%.*]] = alloca [[STRUCT_DOUBLE_CAP_ARRAY:%.*]], align 8
// RV32IXCHERI-NEXT:    [[BYVAL_TEMP7:%.*]] = alloca [[STRUCT_MIXED:%.*]], align 8
// RV32IXCHERI-NEXT:    [[BYVAL_TEMP8:%.*]] = alloca [[UNION_INT_OR_CAP:%.*]], align 8
// RV32IXCHERI-NEXT:    store ptr addrspace(200) null, ptr [[NULL_CAP]], align 8
// RV32IXCHERI-NEXT:    store ptr addrspace(200) null, ptr [[NULL_UINTCAP]], align 8
// RV32IXCHERI-NEXT:    [[TMP0:%.*]] = load ptr addrspace(200), ptr [[NULL_CAP]], align 8
// RV32IXCHERI-NEXT:    [[TMP1:%.*]] = load ptr addrspace(200), ptr [[NULL_UINTCAP]], align 8
// RV32IXCHERI-NEXT:    [[TMP2:%.*]] = load ptr addrspace(200), ptr @cap, align 8
// RV32IXCHERI-NEXT:    [[TMP3:%.*]] = load ptr addrspace(200), ptr @uintcap, align 8
// RV32IXCHERI-NEXT:    store ptr addrspace(200) [[TMP0]], ptr [[INDIRECT_ARG_TEMP]], align 8
// RV32IXCHERI-NEXT:    store ptr addrspace(200) [[TMP1]], ptr [[INDIRECT_ARG_TEMP1]], align 8
// RV32IXCHERI-NEXT:    store ptr addrspace(200) [[TMP2]], ptr [[INDIRECT_ARG_TEMP2]], align 8
// RV32IXCHERI-NEXT:    store ptr addrspace(200) [[TMP3]], ptr [[INDIRECT_ARG_TEMP3]], align 8
// RV32IXCHERI-NEXT:    call void (i32, ...) @callee(i32 noundef 0, ptr noundef [[INDIRECT_ARG_TEMP]], ptr noundef [[INDIRECT_ARG_TEMP1]], ptr noundef [[INDIRECT_ARG_TEMP2]], ptr noundef [[INDIRECT_ARG_TEMP3]])
// RV32IXCHERI-NEXT:    call void @llvm.memcpy.p0.p0.i32(ptr align 8 [[BYVAL_TEMP]], ptr align 8 @single_cap, i32 8, i1 false)
// RV32IXCHERI-NEXT:    call void (i32, ...) @callee(i32 noundef 1, ptr noundef [[BYVAL_TEMP]])
// RV32IXCHERI-NEXT:    call void @llvm.memcpy.p0.p0.i32(ptr align 8 [[BYVAL_TEMP4]], ptr align 8 @double_cap, i32 16, i1 false)
// RV32IXCHERI-NEXT:    call void (i32, ...) @callee(i32 noundef 2, ptr noundef [[BYVAL_TEMP4]])
// RV32IXCHERI-NEXT:    call void @llvm.memcpy.p0.p0.i32(ptr align 8 [[BYVAL_TEMP5]], ptr align 8 @single_cap_array, i32 8, i1 false)
// RV32IXCHERI-NEXT:    call void (i32, ...) @callee(i32 noundef 3, ptr noundef [[BYVAL_TEMP5]])
// RV32IXCHERI-NEXT:    call void @llvm.memcpy.p0.p0.i32(ptr align 8 [[BYVAL_TEMP6]], ptr align 8 @double_cap_array, i32 16, i1 false)
// RV32IXCHERI-NEXT:    call void (i32, ...) @callee(i32 noundef 4, ptr noundef [[BYVAL_TEMP6]])
// RV32IXCHERI-NEXT:    call void @llvm.memcpy.p0.p0.i32(ptr align 8 [[BYVAL_TEMP7]], ptr align 8 @mixed, i32 16, i1 false)
// RV32IXCHERI-NEXT:    call void (i32, ...) @callee(i32 noundef 5, ptr noundef [[BYVAL_TEMP7]])
// RV32IXCHERI-NEXT:    call void @llvm.memcpy.p0.p0.i32(ptr align 8 [[BYVAL_TEMP8]], ptr align 8 @int_or_cap, i32 8, i1 false)
// RV32IXCHERI-NEXT:    call void (i32, ...) @callee(i32 noundef 6, ptr noundef [[BYVAL_TEMP8]])
// RV32IXCHERI-NEXT:    ret void
//
// RV64IXCHERI-LABEL: define {{[^@]+}}@caller
// RV64IXCHERI-SAME: () #[[ATTR0:[0-9]+]] {
// RV64IXCHERI-NEXT:  entry:
// RV64IXCHERI-NEXT:    [[NULL_CAP:%.*]] = alloca ptr addrspace(200), align 16
// RV64IXCHERI-NEXT:    [[NULL_UINTCAP:%.*]] = alloca ptr addrspace(200), align 16
// RV64IXCHERI-NEXT:    [[INDIRECT_ARG_TEMP:%.*]] = alloca ptr addrspace(200), align 16
// RV64IXCHERI-NEXT:    [[INDIRECT_ARG_TEMP1:%.*]] = alloca ptr addrspace(200), align 16
// RV64IXCHERI-NEXT:    [[INDIRECT_ARG_TEMP2:%.*]] = alloca ptr addrspace(200), align 16
// RV64IXCHERI-NEXT:    [[INDIRECT_ARG_TEMP3:%.*]] = alloca ptr addrspace(200), align 16
// RV64IXCHERI-NEXT:    [[BYVAL_TEMP:%.*]] = alloca [[STRUCT_SINGLE_CAP:%.*]], align 16
// RV64IXCHERI-NEXT:    [[BYVAL_TEMP4:%.*]] = alloca [[STRUCT_DOUBLE_CAP:%.*]], align 16
// RV64IXCHERI-NEXT:    [[BYVAL_TEMP5:%.*]] = alloca [[STRUCT_SINGLE_CAP_ARRAY:%.*]], align 16
// RV64IXCHERI-NEXT:    [[BYVAL_TEMP6:%.*]] = alloca [[STRUCT_DOUBLE_CAP_ARRAY:%.*]], align 16
// RV64IXCHERI-NEXT:    [[BYVAL_TEMP7:%.*]] = alloca [[STRUCT_MIXED:%.*]], align 16
// RV64IXCHERI-NEXT:    [[BYVAL_TEMP8:%.*]] = alloca [[UNION_INT_OR_CAP:%.*]], align 16
// RV64IXCHERI-NEXT:    store ptr addrspace(200) null, ptr [[NULL_CAP]], align 16
// RV64IXCHERI-NEXT:    store ptr addrspace(200) null, ptr [[NULL_UINTCAP]], align 16
// RV64IXCHERI-NEXT:    [[TMP0:%.*]] = load ptr addrspace(200), ptr [[NULL_CAP]], align 16
// RV64IXCHERI-NEXT:    [[TMP1:%.*]] = load ptr addrspace(200), ptr [[NULL_UINTCAP]], align 16
// RV64IXCHERI-NEXT:    [[TMP2:%.*]] = load ptr addrspace(200), ptr @cap, align 16
// RV64IXCHERI-NEXT:    [[TMP3:%.*]] = load ptr addrspace(200), ptr @uintcap, align 16
// RV64IXCHERI-NEXT:    store ptr addrspace(200) [[TMP0]], ptr [[INDIRECT_ARG_TEMP]], align 16
// RV64IXCHERI-NEXT:    store ptr addrspace(200) [[TMP1]], ptr [[INDIRECT_ARG_TEMP1]], align 16
// RV64IXCHERI-NEXT:    store ptr addrspace(200) [[TMP2]], ptr [[INDIRECT_ARG_TEMP2]], align 16
// RV64IXCHERI-NEXT:    store ptr addrspace(200) [[TMP3]], ptr [[INDIRECT_ARG_TEMP3]], align 16
// RV64IXCHERI-NEXT:    call void (i64, ...) @callee(i64 noundef 0, ptr noundef [[INDIRECT_ARG_TEMP]], ptr noundef [[INDIRECT_ARG_TEMP1]], ptr noundef [[INDIRECT_ARG_TEMP2]], ptr noundef [[INDIRECT_ARG_TEMP3]])
// RV64IXCHERI-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[BYVAL_TEMP]], ptr align 16 @single_cap, i64 16, i1 false)
// RV64IXCHERI-NEXT:    call void (i64, ...) @callee(i64 noundef 1, ptr noundef [[BYVAL_TEMP]])
// RV64IXCHERI-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[BYVAL_TEMP4]], ptr align 16 @double_cap, i64 32, i1 false)
// RV64IXCHERI-NEXT:    call void (i64, ...) @callee(i64 noundef 2, ptr noundef [[BYVAL_TEMP4]])
// RV64IXCHERI-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[BYVAL_TEMP5]], ptr align 16 @single_cap_array, i64 16, i1 false)
// RV64IXCHERI-NEXT:    call void (i64, ...) @callee(i64 noundef 3, ptr noundef [[BYVAL_TEMP5]])
// RV64IXCHERI-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[BYVAL_TEMP6]], ptr align 16 @double_cap_array, i64 32, i1 false)
// RV64IXCHERI-NEXT:    call void (i64, ...) @callee(i64 noundef 4, ptr noundef [[BYVAL_TEMP6]])
// RV64IXCHERI-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[BYVAL_TEMP7]], ptr align 16 @mixed, i64 32, i1 false)
// RV64IXCHERI-NEXT:    call void (i64, ...) @callee(i64 noundef 5, ptr noundef [[BYVAL_TEMP7]])
// RV64IXCHERI-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[BYVAL_TEMP8]], ptr align 16 @int_or_cap, i64 16, i1 false)
// RV64IXCHERI-NEXT:    call void (i64, ...) @callee(i64 noundef 6, ptr noundef [[BYVAL_TEMP8]])
// RV64IXCHERI-NEXT:    ret void
//
void caller(void) {
  void * __capability null_cap = (void * __capability)0;
  __uintcap_t null_uintcap = 0;

  callee(0, null_cap, null_uintcap, cap, uintcap);
  callee(1, single_cap);
  callee(2, double_cap);
  callee(3, single_cap_array);
  callee(4, double_cap_array);
  callee(5, mixed);
  callee(6, int_or_cap);
}

// MIPS-LABEL: define {{[^@]+}}@callee
// MIPS-SAME: (i64 noundef signext [[SEL:%.*]], ...) #[[ATTR0]] {
// MIPS-NEXT:  entry:
// MIPS-NEXT:    [[SEL_ADDR:%.*]] = alloca i64, align 8
// MIPS-NEXT:    [[NULL_CAP:%.*]] = alloca ptr addrspace(200), align 16
// MIPS-NEXT:    [[NULL_UINTCAP:%.*]] = alloca ptr addrspace(200), align 16
// MIPS-NEXT:    [[CAP:%.*]] = alloca ptr addrspace(200), align 16
// MIPS-NEXT:    [[UINTCAP:%.*]] = alloca ptr addrspace(200), align 16
// MIPS-NEXT:    [[SINGLE_CAP:%.*]] = alloca [[STRUCT_SINGLE_CAP:%.*]], align 16
// MIPS-NEXT:    [[DOUBLE_CAP:%.*]] = alloca [[STRUCT_DOUBLE_CAP:%.*]], align 16
// MIPS-NEXT:    [[SINGLE_CAP_ARRAY:%.*]] = alloca [[STRUCT_SINGLE_CAP_ARRAY:%.*]], align 16
// MIPS-NEXT:    [[DOUBLE_CAP_ARRAY:%.*]] = alloca [[STRUCT_DOUBLE_CAP_ARRAY:%.*]], align 16
// MIPS-NEXT:    [[MIXED:%.*]] = alloca [[STRUCT_MIXED:%.*]], align 16
// MIPS-NEXT:    [[INT_OR_CAP:%.*]] = alloca [[UNION_INT_OR_CAP:%.*]], align 16
// MIPS-NEXT:    [[AP:%.*]] = alloca ptr, align 8
// MIPS-NEXT:    store i64 [[SEL]], ptr [[SEL_ADDR]], align 8
// MIPS-NEXT:    call void @llvm.va_start.p0(ptr [[AP]])
// MIPS-NEXT:    [[TMP0:%.*]] = load i64, ptr [[SEL_ADDR]], align 8
// MIPS-NEXT:    switch i64 [[TMP0]], label [[SW_EPILOG:%.*]] [
// MIPS-NEXT:    i64 0, label [[SW_BB:%.*]]
// MIPS-NEXT:    i64 1, label [[SW_BB7:%.*]]
// MIPS-NEXT:    i64 2, label [[SW_BB10:%.*]]
// MIPS-NEXT:    i64 3, label [[SW_BB13:%.*]]
// MIPS-NEXT:    i64 4, label [[SW_BB16:%.*]]
// MIPS-NEXT:    i64 5, label [[SW_BB19:%.*]]
// MIPS-NEXT:    i64 6, label [[SW_BB22:%.*]]
// MIPS-NEXT:    ]
// MIPS:       sw.bb:
// MIPS-NEXT:    [[ARGP_CUR:%.*]] = load ptr, ptr [[AP]], align 8
// MIPS-NEXT:    [[ARGP_NEXT:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR]], i64 8
// MIPS-NEXT:    store ptr [[ARGP_NEXT]], ptr [[AP]], align 8
// MIPS-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[ARGP_CUR]], align 8
// MIPS-NEXT:    [[TMP2:%.*]] = load ptr addrspace(200), ptr [[TMP1]], align 16
// MIPS-NEXT:    store volatile ptr addrspace(200) [[TMP2]], ptr [[NULL_CAP]], align 16
// MIPS-NEXT:    [[ARGP_CUR1:%.*]] = load ptr, ptr [[AP]], align 8
// MIPS-NEXT:    [[ARGP_NEXT2:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR1]], i64 8
// MIPS-NEXT:    store ptr [[ARGP_NEXT2]], ptr [[AP]], align 8
// MIPS-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[ARGP_CUR1]], align 8
// MIPS-NEXT:    [[TMP4:%.*]] = load ptr addrspace(200), ptr [[TMP3]], align 16
// MIPS-NEXT:    store volatile ptr addrspace(200) [[TMP4]], ptr [[NULL_UINTCAP]], align 16
// MIPS-NEXT:    [[ARGP_CUR3:%.*]] = load ptr, ptr [[AP]], align 8
// MIPS-NEXT:    [[ARGP_NEXT4:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR3]], i64 8
// MIPS-NEXT:    store ptr [[ARGP_NEXT4]], ptr [[AP]], align 8
// MIPS-NEXT:    [[TMP5:%.*]] = load ptr, ptr [[ARGP_CUR3]], align 8
// MIPS-NEXT:    [[TMP6:%.*]] = load ptr addrspace(200), ptr [[TMP5]], align 16
// MIPS-NEXT:    store volatile ptr addrspace(200) [[TMP6]], ptr [[CAP]], align 16
// MIPS-NEXT:    [[ARGP_CUR5:%.*]] = load ptr, ptr [[AP]], align 8
// MIPS-NEXT:    [[ARGP_NEXT6:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR5]], i64 8
// MIPS-NEXT:    store ptr [[ARGP_NEXT6]], ptr [[AP]], align 8
// MIPS-NEXT:    [[TMP7:%.*]] = load ptr, ptr [[ARGP_CUR5]], align 8
// MIPS-NEXT:    [[TMP8:%.*]] = load ptr addrspace(200), ptr [[TMP7]], align 16
// MIPS-NEXT:    store volatile ptr addrspace(200) [[TMP8]], ptr [[UINTCAP]], align 16
// MIPS-NEXT:    br label [[SW_EPILOG]]
// MIPS:       sw.bb7:
// MIPS-NEXT:    [[ARGP_CUR8:%.*]] = load ptr, ptr [[AP]], align 8
// MIPS-NEXT:    [[ARGP_NEXT9:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR8]], i64 8
// MIPS-NEXT:    store ptr [[ARGP_NEXT9]], ptr [[AP]], align 8
// MIPS-NEXT:    [[TMP9:%.*]] = load ptr, ptr [[ARGP_CUR8]], align 8
// MIPS-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[SINGLE_CAP]], ptr align 16 [[TMP9]], i64 16, i1 true)
// MIPS-NEXT:    br label [[SW_EPILOG]]
// MIPS:       sw.bb10:
// MIPS-NEXT:    [[ARGP_CUR11:%.*]] = load ptr, ptr [[AP]], align 8
// MIPS-NEXT:    [[ARGP_NEXT12:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR11]], i64 8
// MIPS-NEXT:    store ptr [[ARGP_NEXT12]], ptr [[AP]], align 8
// MIPS-NEXT:    [[TMP10:%.*]] = load ptr, ptr [[ARGP_CUR11]], align 8
// MIPS-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[DOUBLE_CAP]], ptr align 16 [[TMP10]], i64 32, i1 true)
// MIPS-NEXT:    br label [[SW_EPILOG]]
// MIPS:       sw.bb13:
// MIPS-NEXT:    [[ARGP_CUR14:%.*]] = load ptr, ptr [[AP]], align 8
// MIPS-NEXT:    [[ARGP_NEXT15:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR14]], i64 8
// MIPS-NEXT:    store ptr [[ARGP_NEXT15]], ptr [[AP]], align 8
// MIPS-NEXT:    [[TMP11:%.*]] = load ptr, ptr [[ARGP_CUR14]], align 8
// MIPS-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[SINGLE_CAP_ARRAY]], ptr align 16 [[TMP11]], i64 16, i1 true)
// MIPS-NEXT:    br label [[SW_EPILOG]]
// MIPS:       sw.bb16:
// MIPS-NEXT:    [[ARGP_CUR17:%.*]] = load ptr, ptr [[AP]], align 8
// MIPS-NEXT:    [[ARGP_NEXT18:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR17]], i64 8
// MIPS-NEXT:    store ptr [[ARGP_NEXT18]], ptr [[AP]], align 8
// MIPS-NEXT:    [[TMP12:%.*]] = load ptr, ptr [[ARGP_CUR17]], align 8
// MIPS-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[DOUBLE_CAP_ARRAY]], ptr align 16 [[TMP12]], i64 32, i1 true)
// MIPS-NEXT:    br label [[SW_EPILOG]]
// MIPS:       sw.bb19:
// MIPS-NEXT:    [[ARGP_CUR20:%.*]] = load ptr, ptr [[AP]], align 8
// MIPS-NEXT:    [[ARGP_NEXT21:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR20]], i64 8
// MIPS-NEXT:    store ptr [[ARGP_NEXT21]], ptr [[AP]], align 8
// MIPS-NEXT:    [[TMP13:%.*]] = load ptr, ptr [[ARGP_CUR20]], align 8
// MIPS-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[MIXED]], ptr align 16 [[TMP13]], i64 32, i1 true)
// MIPS-NEXT:    br label [[SW_EPILOG]]
// MIPS:       sw.bb22:
// MIPS-NEXT:    [[ARGP_CUR23:%.*]] = load ptr, ptr [[AP]], align 8
// MIPS-NEXT:    [[ARGP_NEXT24:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR23]], i64 8
// MIPS-NEXT:    store ptr [[ARGP_NEXT24]], ptr [[AP]], align 8
// MIPS-NEXT:    [[TMP14:%.*]] = load ptr, ptr [[ARGP_CUR23]], align 8
// MIPS-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[INT_OR_CAP]], ptr align 16 [[TMP14]], i64 16, i1 true)
// MIPS-NEXT:    br label [[SW_EPILOG]]
// MIPS:       sw.epilog:
// MIPS-NEXT:    call void @llvm.va_end.p0(ptr [[AP]])
// MIPS-NEXT:    ret void
//
// RV32IXCHERI-LABEL: define {{[^@]+}}@callee
// RV32IXCHERI-SAME: (i32 noundef [[SEL:%.*]], ...) #[[ATTR0]] {
// RV32IXCHERI-NEXT:  entry:
// RV32IXCHERI-NEXT:    [[SEL_ADDR:%.*]] = alloca i32, align 4
// RV32IXCHERI-NEXT:    [[NULL_CAP:%.*]] = alloca ptr addrspace(200), align 8
// RV32IXCHERI-NEXT:    [[NULL_UINTCAP:%.*]] = alloca ptr addrspace(200), align 8
// RV32IXCHERI-NEXT:    [[CAP:%.*]] = alloca ptr addrspace(200), align 8
// RV32IXCHERI-NEXT:    [[UINTCAP:%.*]] = alloca ptr addrspace(200), align 8
// RV32IXCHERI-NEXT:    [[SINGLE_CAP:%.*]] = alloca [[STRUCT_SINGLE_CAP:%.*]], align 8
// RV32IXCHERI-NEXT:    [[DOUBLE_CAP:%.*]] = alloca [[STRUCT_DOUBLE_CAP:%.*]], align 8
// RV32IXCHERI-NEXT:    [[SINGLE_CAP_ARRAY:%.*]] = alloca [[STRUCT_SINGLE_CAP_ARRAY:%.*]], align 8
// RV32IXCHERI-NEXT:    [[DOUBLE_CAP_ARRAY:%.*]] = alloca [[STRUCT_DOUBLE_CAP_ARRAY:%.*]], align 8
// RV32IXCHERI-NEXT:    [[MIXED:%.*]] = alloca [[STRUCT_MIXED:%.*]], align 8
// RV32IXCHERI-NEXT:    [[INT_OR_CAP:%.*]] = alloca [[UNION_INT_OR_CAP:%.*]], align 8
// RV32IXCHERI-NEXT:    [[AP:%.*]] = alloca ptr, align 4
// RV32IXCHERI-NEXT:    store i32 [[SEL]], ptr [[SEL_ADDR]], align 4
// RV32IXCHERI-NEXT:    call void @llvm.va_start.p0(ptr [[AP]])
// RV32IXCHERI-NEXT:    [[TMP0:%.*]] = load i32, ptr [[SEL_ADDR]], align 4
// RV32IXCHERI-NEXT:    switch i32 [[TMP0]], label [[SW_EPILOG:%.*]] [
// RV32IXCHERI-NEXT:    i32 0, label [[SW_BB:%.*]]
// RV32IXCHERI-NEXT:    i32 1, label [[SW_BB7:%.*]]
// RV32IXCHERI-NEXT:    i32 2, label [[SW_BB10:%.*]]
// RV32IXCHERI-NEXT:    i32 3, label [[SW_BB13:%.*]]
// RV32IXCHERI-NEXT:    i32 4, label [[SW_BB16:%.*]]
// RV32IXCHERI-NEXT:    i32 5, label [[SW_BB19:%.*]]
// RV32IXCHERI-NEXT:    i32 6, label [[SW_BB22:%.*]]
// RV32IXCHERI-NEXT:    ]
// RV32IXCHERI:       sw.bb:
// RV32IXCHERI-NEXT:    [[ARGP_CUR:%.*]] = load ptr, ptr [[AP]], align 4
// RV32IXCHERI-NEXT:    [[ARGP_NEXT:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR]], i32 4
// RV32IXCHERI-NEXT:    store ptr [[ARGP_NEXT]], ptr [[AP]], align 4
// RV32IXCHERI-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[ARGP_CUR]], align 4
// RV32IXCHERI-NEXT:    [[TMP2:%.*]] = load ptr addrspace(200), ptr [[TMP1]], align 8
// RV32IXCHERI-NEXT:    store volatile ptr addrspace(200) [[TMP2]], ptr [[NULL_CAP]], align 8
// RV32IXCHERI-NEXT:    [[ARGP_CUR1:%.*]] = load ptr, ptr [[AP]], align 4
// RV32IXCHERI-NEXT:    [[ARGP_NEXT2:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR1]], i32 4
// RV32IXCHERI-NEXT:    store ptr [[ARGP_NEXT2]], ptr [[AP]], align 4
// RV32IXCHERI-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[ARGP_CUR1]], align 4
// RV32IXCHERI-NEXT:    [[TMP4:%.*]] = load ptr addrspace(200), ptr [[TMP3]], align 8
// RV32IXCHERI-NEXT:    store volatile ptr addrspace(200) [[TMP4]], ptr [[NULL_UINTCAP]], align 8
// RV32IXCHERI-NEXT:    [[ARGP_CUR3:%.*]] = load ptr, ptr [[AP]], align 4
// RV32IXCHERI-NEXT:    [[ARGP_NEXT4:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR3]], i32 4
// RV32IXCHERI-NEXT:    store ptr [[ARGP_NEXT4]], ptr [[AP]], align 4
// RV32IXCHERI-NEXT:    [[TMP5:%.*]] = load ptr, ptr [[ARGP_CUR3]], align 4
// RV32IXCHERI-NEXT:    [[TMP6:%.*]] = load ptr addrspace(200), ptr [[TMP5]], align 8
// RV32IXCHERI-NEXT:    store volatile ptr addrspace(200) [[TMP6]], ptr [[CAP]], align 8
// RV32IXCHERI-NEXT:    [[ARGP_CUR5:%.*]] = load ptr, ptr [[AP]], align 4
// RV32IXCHERI-NEXT:    [[ARGP_NEXT6:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR5]], i32 4
// RV32IXCHERI-NEXT:    store ptr [[ARGP_NEXT6]], ptr [[AP]], align 4
// RV32IXCHERI-NEXT:    [[TMP7:%.*]] = load ptr, ptr [[ARGP_CUR5]], align 4
// RV32IXCHERI-NEXT:    [[TMP8:%.*]] = load ptr addrspace(200), ptr [[TMP7]], align 8
// RV32IXCHERI-NEXT:    store volatile ptr addrspace(200) [[TMP8]], ptr [[UINTCAP]], align 8
// RV32IXCHERI-NEXT:    br label [[SW_EPILOG]]
// RV32IXCHERI:       sw.bb7:
// RV32IXCHERI-NEXT:    [[ARGP_CUR8:%.*]] = load ptr, ptr [[AP]], align 4
// RV32IXCHERI-NEXT:    [[ARGP_NEXT9:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR8]], i32 4
// RV32IXCHERI-NEXT:    store ptr [[ARGP_NEXT9]], ptr [[AP]], align 4
// RV32IXCHERI-NEXT:    [[TMP9:%.*]] = load ptr, ptr [[ARGP_CUR8]], align 4
// RV32IXCHERI-NEXT:    call void @llvm.memcpy.p0.p0.i32(ptr align 8 [[SINGLE_CAP]], ptr align 8 [[TMP9]], i32 8, i1 true)
// RV32IXCHERI-NEXT:    br label [[SW_EPILOG]]
// RV32IXCHERI:       sw.bb10:
// RV32IXCHERI-NEXT:    [[ARGP_CUR11:%.*]] = load ptr, ptr [[AP]], align 4
// RV32IXCHERI-NEXT:    [[ARGP_NEXT12:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR11]], i32 4
// RV32IXCHERI-NEXT:    store ptr [[ARGP_NEXT12]], ptr [[AP]], align 4
// RV32IXCHERI-NEXT:    [[TMP10:%.*]] = load ptr, ptr [[ARGP_CUR11]], align 4
// RV32IXCHERI-NEXT:    call void @llvm.memcpy.p0.p0.i32(ptr align 8 [[DOUBLE_CAP]], ptr align 8 [[TMP10]], i32 16, i1 true)
// RV32IXCHERI-NEXT:    br label [[SW_EPILOG]]
// RV32IXCHERI:       sw.bb13:
// RV32IXCHERI-NEXT:    [[ARGP_CUR14:%.*]] = load ptr, ptr [[AP]], align 4
// RV32IXCHERI-NEXT:    [[ARGP_NEXT15:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR14]], i32 4
// RV32IXCHERI-NEXT:    store ptr [[ARGP_NEXT15]], ptr [[AP]], align 4
// RV32IXCHERI-NEXT:    [[TMP11:%.*]] = load ptr, ptr [[ARGP_CUR14]], align 4
// RV32IXCHERI-NEXT:    call void @llvm.memcpy.p0.p0.i32(ptr align 8 [[SINGLE_CAP_ARRAY]], ptr align 8 [[TMP11]], i32 8, i1 true)
// RV32IXCHERI-NEXT:    br label [[SW_EPILOG]]
// RV32IXCHERI:       sw.bb16:
// RV32IXCHERI-NEXT:    [[ARGP_CUR17:%.*]] = load ptr, ptr [[AP]], align 4
// RV32IXCHERI-NEXT:    [[ARGP_NEXT18:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR17]], i32 4
// RV32IXCHERI-NEXT:    store ptr [[ARGP_NEXT18]], ptr [[AP]], align 4
// RV32IXCHERI-NEXT:    [[TMP12:%.*]] = load ptr, ptr [[ARGP_CUR17]], align 4
// RV32IXCHERI-NEXT:    call void @llvm.memcpy.p0.p0.i32(ptr align 8 [[DOUBLE_CAP_ARRAY]], ptr align 8 [[TMP12]], i32 16, i1 true)
// RV32IXCHERI-NEXT:    br label [[SW_EPILOG]]
// RV32IXCHERI:       sw.bb19:
// RV32IXCHERI-NEXT:    [[ARGP_CUR20:%.*]] = load ptr, ptr [[AP]], align 4
// RV32IXCHERI-NEXT:    [[ARGP_NEXT21:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR20]], i32 4
// RV32IXCHERI-NEXT:    store ptr [[ARGP_NEXT21]], ptr [[AP]], align 4
// RV32IXCHERI-NEXT:    [[TMP13:%.*]] = load ptr, ptr [[ARGP_CUR20]], align 4
// RV32IXCHERI-NEXT:    call void @llvm.memcpy.p0.p0.i32(ptr align 8 [[MIXED]], ptr align 8 [[TMP13]], i32 16, i1 true)
// RV32IXCHERI-NEXT:    br label [[SW_EPILOG]]
// RV32IXCHERI:       sw.bb22:
// RV32IXCHERI-NEXT:    [[ARGP_CUR23:%.*]] = load ptr, ptr [[AP]], align 4
// RV32IXCHERI-NEXT:    [[ARGP_NEXT24:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR23]], i32 4
// RV32IXCHERI-NEXT:    store ptr [[ARGP_NEXT24]], ptr [[AP]], align 4
// RV32IXCHERI-NEXT:    [[TMP14:%.*]] = load ptr, ptr [[ARGP_CUR23]], align 4
// RV32IXCHERI-NEXT:    call void @llvm.memcpy.p0.p0.i32(ptr align 8 [[INT_OR_CAP]], ptr align 8 [[TMP14]], i32 8, i1 true)
// RV32IXCHERI-NEXT:    br label [[SW_EPILOG]]
// RV32IXCHERI:       sw.epilog:
// RV32IXCHERI-NEXT:    call void @llvm.va_end.p0(ptr [[AP]])
// RV32IXCHERI-NEXT:    ret void
//
// RV64IXCHERI-LABEL: define {{[^@]+}}@callee
// RV64IXCHERI-SAME: (i64 noundef [[SEL:%.*]], ...) #[[ATTR0]] {
// RV64IXCHERI-NEXT:  entry:
// RV64IXCHERI-NEXT:    [[SEL_ADDR:%.*]] = alloca i64, align 8
// RV64IXCHERI-NEXT:    [[NULL_CAP:%.*]] = alloca ptr addrspace(200), align 16
// RV64IXCHERI-NEXT:    [[NULL_UINTCAP:%.*]] = alloca ptr addrspace(200), align 16
// RV64IXCHERI-NEXT:    [[CAP:%.*]] = alloca ptr addrspace(200), align 16
// RV64IXCHERI-NEXT:    [[UINTCAP:%.*]] = alloca ptr addrspace(200), align 16
// RV64IXCHERI-NEXT:    [[SINGLE_CAP:%.*]] = alloca [[STRUCT_SINGLE_CAP:%.*]], align 16
// RV64IXCHERI-NEXT:    [[DOUBLE_CAP:%.*]] = alloca [[STRUCT_DOUBLE_CAP:%.*]], align 16
// RV64IXCHERI-NEXT:    [[SINGLE_CAP_ARRAY:%.*]] = alloca [[STRUCT_SINGLE_CAP_ARRAY:%.*]], align 16
// RV64IXCHERI-NEXT:    [[DOUBLE_CAP_ARRAY:%.*]] = alloca [[STRUCT_DOUBLE_CAP_ARRAY:%.*]], align 16
// RV64IXCHERI-NEXT:    [[MIXED:%.*]] = alloca [[STRUCT_MIXED:%.*]], align 16
// RV64IXCHERI-NEXT:    [[INT_OR_CAP:%.*]] = alloca [[UNION_INT_OR_CAP:%.*]], align 16
// RV64IXCHERI-NEXT:    [[AP:%.*]] = alloca ptr, align 8
// RV64IXCHERI-NEXT:    store i64 [[SEL]], ptr [[SEL_ADDR]], align 8
// RV64IXCHERI-NEXT:    call void @llvm.va_start.p0(ptr [[AP]])
// RV64IXCHERI-NEXT:    [[TMP0:%.*]] = load i64, ptr [[SEL_ADDR]], align 8
// RV64IXCHERI-NEXT:    switch i64 [[TMP0]], label [[SW_EPILOG:%.*]] [
// RV64IXCHERI-NEXT:    i64 0, label [[SW_BB:%.*]]
// RV64IXCHERI-NEXT:    i64 1, label [[SW_BB7:%.*]]
// RV64IXCHERI-NEXT:    i64 2, label [[SW_BB10:%.*]]
// RV64IXCHERI-NEXT:    i64 3, label [[SW_BB13:%.*]]
// RV64IXCHERI-NEXT:    i64 4, label [[SW_BB16:%.*]]
// RV64IXCHERI-NEXT:    i64 5, label [[SW_BB19:%.*]]
// RV64IXCHERI-NEXT:    i64 6, label [[SW_BB22:%.*]]
// RV64IXCHERI-NEXT:    ]
// RV64IXCHERI:       sw.bb:
// RV64IXCHERI-NEXT:    [[ARGP_CUR:%.*]] = load ptr, ptr [[AP]], align 8
// RV64IXCHERI-NEXT:    [[ARGP_NEXT:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR]], i64 8
// RV64IXCHERI-NEXT:    store ptr [[ARGP_NEXT]], ptr [[AP]], align 8
// RV64IXCHERI-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[ARGP_CUR]], align 8
// RV64IXCHERI-NEXT:    [[TMP2:%.*]] = load ptr addrspace(200), ptr [[TMP1]], align 16
// RV64IXCHERI-NEXT:    store volatile ptr addrspace(200) [[TMP2]], ptr [[NULL_CAP]], align 16
// RV64IXCHERI-NEXT:    [[ARGP_CUR1:%.*]] = load ptr, ptr [[AP]], align 8
// RV64IXCHERI-NEXT:    [[ARGP_NEXT2:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR1]], i64 8
// RV64IXCHERI-NEXT:    store ptr [[ARGP_NEXT2]], ptr [[AP]], align 8
// RV64IXCHERI-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[ARGP_CUR1]], align 8
// RV64IXCHERI-NEXT:    [[TMP4:%.*]] = load ptr addrspace(200), ptr [[TMP3]], align 16
// RV64IXCHERI-NEXT:    store volatile ptr addrspace(200) [[TMP4]], ptr [[NULL_UINTCAP]], align 16
// RV64IXCHERI-NEXT:    [[ARGP_CUR3:%.*]] = load ptr, ptr [[AP]], align 8
// RV64IXCHERI-NEXT:    [[ARGP_NEXT4:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR3]], i64 8
// RV64IXCHERI-NEXT:    store ptr [[ARGP_NEXT4]], ptr [[AP]], align 8
// RV64IXCHERI-NEXT:    [[TMP5:%.*]] = load ptr, ptr [[ARGP_CUR3]], align 8
// RV64IXCHERI-NEXT:    [[TMP6:%.*]] = load ptr addrspace(200), ptr [[TMP5]], align 16
// RV64IXCHERI-NEXT:    store volatile ptr addrspace(200) [[TMP6]], ptr [[CAP]], align 16
// RV64IXCHERI-NEXT:    [[ARGP_CUR5:%.*]] = load ptr, ptr [[AP]], align 8
// RV64IXCHERI-NEXT:    [[ARGP_NEXT6:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR5]], i64 8
// RV64IXCHERI-NEXT:    store ptr [[ARGP_NEXT6]], ptr [[AP]], align 8
// RV64IXCHERI-NEXT:    [[TMP7:%.*]] = load ptr, ptr [[ARGP_CUR5]], align 8
// RV64IXCHERI-NEXT:    [[TMP8:%.*]] = load ptr addrspace(200), ptr [[TMP7]], align 16
// RV64IXCHERI-NEXT:    store volatile ptr addrspace(200) [[TMP8]], ptr [[UINTCAP]], align 16
// RV64IXCHERI-NEXT:    br label [[SW_EPILOG]]
// RV64IXCHERI:       sw.bb7:
// RV64IXCHERI-NEXT:    [[ARGP_CUR8:%.*]] = load ptr, ptr [[AP]], align 8
// RV64IXCHERI-NEXT:    [[ARGP_NEXT9:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR8]], i64 8
// RV64IXCHERI-NEXT:    store ptr [[ARGP_NEXT9]], ptr [[AP]], align 8
// RV64IXCHERI-NEXT:    [[TMP9:%.*]] = load ptr, ptr [[ARGP_CUR8]], align 8
// RV64IXCHERI-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[SINGLE_CAP]], ptr align 16 [[TMP9]], i64 16, i1 true)
// RV64IXCHERI-NEXT:    br label [[SW_EPILOG]]
// RV64IXCHERI:       sw.bb10:
// RV64IXCHERI-NEXT:    [[ARGP_CUR11:%.*]] = load ptr, ptr [[AP]], align 8
// RV64IXCHERI-NEXT:    [[ARGP_NEXT12:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR11]], i64 8
// RV64IXCHERI-NEXT:    store ptr [[ARGP_NEXT12]], ptr [[AP]], align 8
// RV64IXCHERI-NEXT:    [[TMP10:%.*]] = load ptr, ptr [[ARGP_CUR11]], align 8
// RV64IXCHERI-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[DOUBLE_CAP]], ptr align 16 [[TMP10]], i64 32, i1 true)
// RV64IXCHERI-NEXT:    br label [[SW_EPILOG]]
// RV64IXCHERI:       sw.bb13:
// RV64IXCHERI-NEXT:    [[ARGP_CUR14:%.*]] = load ptr, ptr [[AP]], align 8
// RV64IXCHERI-NEXT:    [[ARGP_NEXT15:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR14]], i64 8
// RV64IXCHERI-NEXT:    store ptr [[ARGP_NEXT15]], ptr [[AP]], align 8
// RV64IXCHERI-NEXT:    [[TMP11:%.*]] = load ptr, ptr [[ARGP_CUR14]], align 8
// RV64IXCHERI-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[SINGLE_CAP_ARRAY]], ptr align 16 [[TMP11]], i64 16, i1 true)
// RV64IXCHERI-NEXT:    br label [[SW_EPILOG]]
// RV64IXCHERI:       sw.bb16:
// RV64IXCHERI-NEXT:    [[ARGP_CUR17:%.*]] = load ptr, ptr [[AP]], align 8
// RV64IXCHERI-NEXT:    [[ARGP_NEXT18:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR17]], i64 8
// RV64IXCHERI-NEXT:    store ptr [[ARGP_NEXT18]], ptr [[AP]], align 8
// RV64IXCHERI-NEXT:    [[TMP12:%.*]] = load ptr, ptr [[ARGP_CUR17]], align 8
// RV64IXCHERI-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[DOUBLE_CAP_ARRAY]], ptr align 16 [[TMP12]], i64 32, i1 true)
// RV64IXCHERI-NEXT:    br label [[SW_EPILOG]]
// RV64IXCHERI:       sw.bb19:
// RV64IXCHERI-NEXT:    [[ARGP_CUR20:%.*]] = load ptr, ptr [[AP]], align 8
// RV64IXCHERI-NEXT:    [[ARGP_NEXT21:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR20]], i64 8
// RV64IXCHERI-NEXT:    store ptr [[ARGP_NEXT21]], ptr [[AP]], align 8
// RV64IXCHERI-NEXT:    [[TMP13:%.*]] = load ptr, ptr [[ARGP_CUR20]], align 8
// RV64IXCHERI-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[MIXED]], ptr align 16 [[TMP13]], i64 32, i1 true)
// RV64IXCHERI-NEXT:    br label [[SW_EPILOG]]
// RV64IXCHERI:       sw.bb22:
// RV64IXCHERI-NEXT:    [[ARGP_CUR23:%.*]] = load ptr, ptr [[AP]], align 8
// RV64IXCHERI-NEXT:    [[ARGP_NEXT24:%.*]] = getelementptr inbounds i8, ptr [[ARGP_CUR23]], i64 8
// RV64IXCHERI-NEXT:    store ptr [[ARGP_NEXT24]], ptr [[AP]], align 8
// RV64IXCHERI-NEXT:    [[TMP14:%.*]] = load ptr, ptr [[ARGP_CUR23]], align 8
// RV64IXCHERI-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 16 [[INT_OR_CAP]], ptr align 16 [[TMP14]], i64 16, i1 true)
// RV64IXCHERI-NEXT:    br label [[SW_EPILOG]]
// RV64IXCHERI:       sw.epilog:
// RV64IXCHERI-NEXT:    call void @llvm.va_end.p0(ptr [[AP]])
// RV64IXCHERI-NEXT:    ret void
//
void callee(long sel, ...) {
  void * __capability volatile null_cap;
  volatile __uintcap_t null_uintcap;
  void * __capability volatile cap;
  volatile __uintcap_t uintcap;
  volatile struct single_cap single_cap;
  volatile struct double_cap double_cap;
  volatile struct single_cap_array single_cap_array;
  volatile struct double_cap_array double_cap_array;
  volatile struct mixed mixed;
  volatile union int_or_cap int_or_cap;
  __builtin_va_list ap;

  __builtin_va_start(ap, sel);

  switch (sel) {
  case 0:
    null_cap = __builtin_va_arg(ap, void * __capability);
    null_uintcap = __builtin_va_arg(ap, __uintcap_t);
    cap = __builtin_va_arg(ap, void * __capability);
    uintcap = __builtin_va_arg(ap, __uintcap_t);
    break;
  case 1:
    single_cap = __builtin_va_arg(ap, struct single_cap);
    break;
  case 2:
    double_cap = __builtin_va_arg(ap, struct double_cap);
    break;
  case 3:
    single_cap_array = __builtin_va_arg(ap, struct single_cap_array);
    break;
  case 4:
    double_cap_array = __builtin_va_arg(ap, struct double_cap_array);
    break;
  case 5:
    mixed = __builtin_va_arg(ap, struct mixed);
    break;
  case 6:
    int_or_cap = __builtin_va_arg(ap, union int_or_cap);
    break;
  }

  __builtin_va_end(ap);
}

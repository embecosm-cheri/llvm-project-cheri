// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %cheri_purecap_cc1 %s -o - -emit-llvm -O0 | FileCheck %s
// RUN: %cheri_purecap_cc1 %s -o - -emit-llvm -O2 | FileCheck %s -check-prefix CHECK-OPT
// RUN: %cheri_purecap_cc1 %s -o - -emit-llvm -O3 | FileCheck %s -check-prefix CHECK-OPT


#define A (__intcap_t)1
#define B (__intcap_t)(void*)2
#define C (__intcap_t)3
#define D (__intcap_t)(void*)5

// CHECK-LABEL: @x(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca i32, align 4, addrspace(200)
// CHECK-NEXT:    [[Y_ADDR:%.*]] = alloca ptr addrspace(200), align 16, addrspace(200)
// CHECK-NEXT:    store ptr addrspace(200) [[Y:%.*]], ptr addrspace(200) [[Y_ADDR]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[Y_ADDR]], align 16
// CHECK-NEXT:    [[INTCAP_VADDR:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[TMP0]])
// CHECK-NEXT:    switch i64 [[INTCAP_VADDR]], label [[SW_EPILOG:%.*]] [
// CHECK-NEXT:    i64 1, label [[SW_BB:%.*]]
// CHECK-NEXT:    i64 2, label [[SW_BB1:%.*]]
// CHECK-NEXT:    i64 3, label [[SW_BB2:%.*]]
// CHECK-NEXT:    i64 4, label [[SW_BB2]]
// CHECK-NEXT:    i64 5, label [[SW_BB2]]
// CHECK-NEXT:    ]
// CHECK:       sw.bb:
// CHECK-NEXT:    store i32 4, ptr addrspace(200) [[RETVAL]], align 4
// CHECK-NEXT:    br label [[RETURN:%.*]]
// CHECK:       sw.bb1:
// CHECK-NEXT:    store i32 5, ptr addrspace(200) [[RETVAL]], align 4
// CHECK-NEXT:    br label [[RETURN]]
// CHECK:       sw.bb2:
// CHECK-NEXT:    store i32 6, ptr addrspace(200) [[RETVAL]], align 4
// CHECK-NEXT:    br label [[RETURN]]
// CHECK:       sw.epilog:
// CHECK-NEXT:    store i32 0, ptr addrspace(200) [[RETVAL]], align 4
// CHECK-NEXT:    br label [[RETURN]]
// CHECK:       return:
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr addrspace(200) [[RETVAL]], align 4
// CHECK-NEXT:    ret i32 [[TMP1]]
//
// CHECK-OPT-LABEL: @x(
// CHECK-OPT-NEXT:  entry:
// CHECK-OPT-NEXT:    [[INTCAP_VADDR:%.*]] = tail call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[Y:%.*]])
// CHECK-OPT-NEXT:    switch i64 [[INTCAP_VADDR]], label [[SW_EPILOG:%.*]] [
// CHECK-OPT-NEXT:    i64 1, label [[RETURN:%.*]]
// CHECK-OPT-NEXT:    i64 2, label [[SW_BB1:%.*]]
// CHECK-OPT-NEXT:    i64 3, label [[SW_BB2:%.*]]
// CHECK-OPT-NEXT:    i64 4, label [[SW_BB2]]
// CHECK-OPT-NEXT:    i64 5, label [[SW_BB2]]
// CHECK-OPT-NEXT:    ]
// CHECK-OPT:       sw.bb1:
// CHECK-OPT-NEXT:    br label [[RETURN]]
// CHECK-OPT:       sw.bb2:
// CHECK-OPT-NEXT:    br label [[RETURN]]
// CHECK-OPT:       sw.epilog:
// CHECK-OPT-NEXT:    br label [[RETURN]]
// CHECK-OPT:       return:
// CHECK-OPT-NEXT:    [[RETVAL_0:%.*]] = phi i32 [ 0, [[SW_EPILOG]] ], [ 6, [[SW_BB2]] ], [ 5, [[SW_BB1]] ], [ 4, [[ENTRY:%.*]] ]
// CHECK-OPT-NEXT:    ret i32 [[RETVAL_0]]
//
int x(__intcap_t y)
{
  switch (y)
  {
    case A: return 4;
    case B: return 5;
    case C...D: return 6;
  }
  return 0;
}

// CHECK-LABEL: @y(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca i32, align 4, addrspace(200)
// CHECK-NEXT:    [[FOO:%.*]] = alloca ptr addrspace(200), align 16, addrspace(200)
// CHECK-NEXT:    store ptr addrspace(200) getelementptr (i8, ptr addrspace(200) null, i64 3), ptr addrspace(200) [[FOO]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[FOO]], align 16
// CHECK-NEXT:    [[INTCAP_VADDR:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[TMP0]])
// CHECK-NEXT:    switch i64 [[INTCAP_VADDR]], label [[SW_EPILOG:%.*]] [
// CHECK-NEXT:    i64 1, label [[SW_BB:%.*]]
// CHECK-NEXT:    i64 2, label [[SW_BB1:%.*]]
// CHECK-NEXT:    i64 3, label [[SW_BB2:%.*]]
// CHECK-NEXT:    i64 4, label [[SW_BB2]]
// CHECK-NEXT:    i64 5, label [[SW_BB2]]
// CHECK-NEXT:    ]
// CHECK:       sw.bb:
// CHECK-NEXT:    store i32 4, ptr addrspace(200) [[RETVAL]], align 4
// CHECK-NEXT:    br label [[RETURN:%.*]]
// CHECK:       sw.bb1:
// CHECK-NEXT:    store i32 5, ptr addrspace(200) [[RETVAL]], align 4
// CHECK-NEXT:    br label [[RETURN]]
// CHECK:       sw.bb2:
// CHECK-NEXT:    store i32 6, ptr addrspace(200) [[RETVAL]], align 4
// CHECK-NEXT:    br label [[RETURN]]
// CHECK:       sw.epilog:
// CHECK-NEXT:    store i32 0, ptr addrspace(200) [[RETVAL]], align 4
// CHECK-NEXT:    br label [[RETURN]]
// CHECK:       return:
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr addrspace(200) [[RETVAL]], align 4
// CHECK-NEXT:    ret i32 [[TMP1]]
//
// CHECK-OPT-LABEL: @y(
// CHECK-OPT-NEXT:  entry:
// CHECK-OPT-NEXT:    ret i32 6
//
int y(void) {
  __intcap_t foo = C;
  switch (foo)
  {
    case A: return 4;
    case B: return 5;
    case C...D: return 6;
  }

  // XXXAR: this is currently not optimized after the fix to https://github.com/CTSRD-CHERI/clang/issues/132
  // with optimization this switch gets constant folded:
  // DONTCHECK-OPT-LABEL: define dso_local signext i32 @y()
  // DONTCHECK-OPT:          ret i32 6
  return 0;
}

char buf[16];

// CHECK-LABEL: @z_long(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca i32, align 4, addrspace(200)
// CHECK-NEXT:    [[SWITCHVAL:%.*]] = alloca ptr addrspace(200), align 16, addrspace(200)
// CHECK-NEXT:    store ptr addrspace(200) @buf, ptr addrspace(200) [[SWITCHVAL]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[SWITCHVAL]], align 16
// CHECK-NEXT:    [[TMP1:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[TMP0]])
// CHECK-NEXT:    switch i64 [[TMP1]], label [[SW_DEFAULT:%.*]] [
// CHECK-NEXT:    i64 0, label [[SW_BB:%.*]]
// CHECK-NEXT:    i64 1, label [[SW_BB1:%.*]]
// CHECK-NEXT:    i64 2, label [[SW_BB2:%.*]]
// CHECK-NEXT:    i64 3, label [[SW_BB3:%.*]]
// CHECK-NEXT:    i64 4, label [[SW_BB4:%.*]]
// CHECK-NEXT:    ]
// CHECK:       sw.bb:
// CHECK-NEXT:    store i32 0, ptr addrspace(200) [[RETVAL]], align 4
// CHECK-NEXT:    br label [[RETURN:%.*]]
// CHECK:       sw.bb1:
// CHECK-NEXT:    store i32 1, ptr addrspace(200) [[RETVAL]], align 4
// CHECK-NEXT:    br label [[RETURN]]
// CHECK:       sw.bb2:
// CHECK-NEXT:    store i32 2, ptr addrspace(200) [[RETVAL]], align 4
// CHECK-NEXT:    br label [[RETURN]]
// CHECK:       sw.bb3:
// CHECK-NEXT:    store i32 3, ptr addrspace(200) [[RETVAL]], align 4
// CHECK-NEXT:    br label [[RETURN]]
// CHECK:       sw.bb4:
// CHECK-NEXT:    store i32 4, ptr addrspace(200) [[RETVAL]], align 4
// CHECK-NEXT:    br label [[RETURN]]
// CHECK:       sw.default:
// CHECK-NEXT:    store i32 -1, ptr addrspace(200) [[RETVAL]], align 4
// CHECK-NEXT:    br label [[RETURN]]
// CHECK:       return:
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr addrspace(200) [[RETVAL]], align 4
// CHECK-NEXT:    ret i32 [[TMP2]]
//
// CHECK-OPT-LABEL: @z_long(
// CHECK-OPT-NEXT:  entry:
// CHECK-OPT-NEXT:    [[TMP0:%.*]] = tail call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) nonnull @buf)
// CHECK-OPT-NEXT:    switch i64 [[TMP0]], label [[SW_DEFAULT:%.*]] [
// CHECK-OPT-NEXT:    i64 0, label [[CLEANUP:%.*]]
// CHECK-OPT-NEXT:    i64 1, label [[SW_BB1:%.*]]
// CHECK-OPT-NEXT:    i64 2, label [[SW_BB2:%.*]]
// CHECK-OPT-NEXT:    i64 3, label [[SW_BB3:%.*]]
// CHECK-OPT-NEXT:    i64 4, label [[SW_BB4:%.*]]
// CHECK-OPT-NEXT:    ]
// CHECK-OPT:       sw.bb1:
// CHECK-OPT-NEXT:    br label [[CLEANUP]]
// CHECK-OPT:       sw.bb2:
// CHECK-OPT-NEXT:    br label [[CLEANUP]]
// CHECK-OPT:       sw.bb3:
// CHECK-OPT-NEXT:    br label [[CLEANUP]]
// CHECK-OPT:       sw.bb4:
// CHECK-OPT-NEXT:    br label [[CLEANUP]]
// CHECK-OPT:       sw.default:
// CHECK-OPT-NEXT:    br label [[CLEANUP]]
// CHECK-OPT:       cleanup:
// CHECK-OPT-NEXT:    [[RETVAL_0:%.*]] = phi i32 [ -1, [[SW_DEFAULT]] ], [ 4, [[SW_BB4]] ], [ 3, [[SW_BB3]] ], [ 2, [[SW_BB2]] ], [ 1, [[SW_BB1]] ], [ 0, [[ENTRY:%.*]] ]
// CHECK-OPT-NEXT:    ret i32 [[RETVAL_0]]
//
int z_long(void) {

  const char* switchval = buf;
  switch ((long)switchval) {
    case 0: return 0;
    case 1: return 1;
    case 2: return 2;
    case 3: return 3;
    case 4: return 4;
    default: return -1;
  }
}

// CHECK-LABEL: @z_intcap(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca i32, align 4, addrspace(200)
// CHECK-NEXT:    [[SWITCHVAL:%.*]] = alloca ptr addrspace(200), align 16, addrspace(200)
// CHECK-NEXT:    store ptr addrspace(200) @buf, ptr addrspace(200) [[SWITCHVAL]], align 16
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[SWITCHVAL]], align 16
// CHECK-NEXT:    [[INTCAP_VADDR:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[TMP0]])
// CHECK-NEXT:    switch i64 [[INTCAP_VADDR]], label [[SW_DEFAULT:%.*]] [
// CHECK-NEXT:    i64 0, label [[SW_BB:%.*]]
// CHECK-NEXT:    i64 1, label [[SW_BB1:%.*]]
// CHECK-NEXT:    i64 2, label [[SW_BB2:%.*]]
// CHECK-NEXT:    i64 3, label [[SW_BB3:%.*]]
// CHECK-NEXT:    i64 4, label [[SW_BB4:%.*]]
// CHECK-NEXT:    ]
// CHECK:       sw.bb:
// CHECK-NEXT:    store i32 0, ptr addrspace(200) [[RETVAL]], align 4
// CHECK-NEXT:    br label [[RETURN:%.*]]
// CHECK:       sw.bb1:
// CHECK-NEXT:    store i32 1, ptr addrspace(200) [[RETVAL]], align 4
// CHECK-NEXT:    br label [[RETURN]]
// CHECK:       sw.bb2:
// CHECK-NEXT:    store i32 2, ptr addrspace(200) [[RETVAL]], align 4
// CHECK-NEXT:    br label [[RETURN]]
// CHECK:       sw.bb3:
// CHECK-NEXT:    store i32 3, ptr addrspace(200) [[RETVAL]], align 4
// CHECK-NEXT:    br label [[RETURN]]
// CHECK:       sw.bb4:
// CHECK-NEXT:    store i32 4, ptr addrspace(200) [[RETVAL]], align 4
// CHECK-NEXT:    br label [[RETURN]]
// CHECK:       sw.default:
// CHECK-NEXT:    store i32 -1, ptr addrspace(200) [[RETVAL]], align 4
// CHECK-NEXT:    br label [[RETURN]]
// CHECK:       return:
// CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr addrspace(200) [[RETVAL]], align 4
// CHECK-NEXT:    ret i32 [[TMP1]]
//
// CHECK-OPT-LABEL: @z_intcap(
// CHECK-OPT-NEXT:  entry:
// CHECK-OPT-NEXT:    [[INTCAP_VADDR:%.*]] = tail call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) nonnull @buf)
// CHECK-OPT-NEXT:    switch i64 [[INTCAP_VADDR]], label [[SW_DEFAULT:%.*]] [
// CHECK-OPT-NEXT:    i64 0, label [[CLEANUP:%.*]]
// CHECK-OPT-NEXT:    i64 1, label [[SW_BB1:%.*]]
// CHECK-OPT-NEXT:    i64 2, label [[SW_BB2:%.*]]
// CHECK-OPT-NEXT:    i64 3, label [[SW_BB3:%.*]]
// CHECK-OPT-NEXT:    i64 4, label [[SW_BB4:%.*]]
// CHECK-OPT-NEXT:    ]
// CHECK-OPT:       sw.bb1:
// CHECK-OPT-NEXT:    br label [[CLEANUP]]
// CHECK-OPT:       sw.bb2:
// CHECK-OPT-NEXT:    br label [[CLEANUP]]
// CHECK-OPT:       sw.bb3:
// CHECK-OPT-NEXT:    br label [[CLEANUP]]
// CHECK-OPT:       sw.bb4:
// CHECK-OPT-NEXT:    br label [[CLEANUP]]
// CHECK-OPT:       sw.default:
// CHECK-OPT-NEXT:    br label [[CLEANUP]]
// CHECK-OPT:       cleanup:
// CHECK-OPT-NEXT:    [[RETVAL_0:%.*]] = phi i32 [ -1, [[SW_DEFAULT]] ], [ 4, [[SW_BB4]] ], [ 3, [[SW_BB3]] ], [ 2, [[SW_BB2]] ], [ 1, [[SW_BB1]] ], [ 0, [[ENTRY:%.*]] ]
// CHECK-OPT-NEXT:    ret i32 [[RETVAL_0]]
//
int z_intcap(void) {
  // Check that we actually switch on the virtual address and not the offset:
  const char* switchval = buf;
  switch ((__intcap_t)switchval) {
    case 0: return 0;
    case 1: return 1;
    case 2: return 2;
    case 3: return 3;
    case 4: return 4;
    default: return -1;
  }

}

// CHECK-LABEL: @z_fixed_offset(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[RETVAL:%.*]] = alloca i32, align 4, addrspace(200)
// CHECK-NEXT:    [[SWITCHVAL:%.*]] = alloca ptr addrspace(200), align 16, addrspace(200)
// CHECK-NEXT:    [[TMP0:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.offset.set.i64(ptr addrspace(200) @buf, i64 4)
// CHECK-NEXT:    store ptr addrspace(200) [[TMP0]], ptr addrspace(200) [[SWITCHVAL]], align 16
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[SWITCHVAL]], align 16
// CHECK-NEXT:    [[INTCAP_VADDR:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[TMP1]])
// CHECK-NEXT:    switch i64 [[INTCAP_VADDR]], label [[SW_DEFAULT:%.*]] [
// CHECK-NEXT:    i64 0, label [[SW_BB:%.*]]
// CHECK-NEXT:    i64 1, label [[SW_BB1:%.*]]
// CHECK-NEXT:    i64 2, label [[SW_BB2:%.*]]
// CHECK-NEXT:    i64 3, label [[SW_BB3:%.*]]
// CHECK-NEXT:    i64 4, label [[SW_BB4:%.*]]
// CHECK-NEXT:    ]
// CHECK:       sw.bb:
// CHECK-NEXT:    store i32 0, ptr addrspace(200) [[RETVAL]], align 4
// CHECK-NEXT:    br label [[RETURN:%.*]]
// CHECK:       sw.bb1:
// CHECK-NEXT:    store i32 1, ptr addrspace(200) [[RETVAL]], align 4
// CHECK-NEXT:    br label [[RETURN]]
// CHECK:       sw.bb2:
// CHECK-NEXT:    store i32 2, ptr addrspace(200) [[RETVAL]], align 4
// CHECK-NEXT:    br label [[RETURN]]
// CHECK:       sw.bb3:
// CHECK-NEXT:    store i32 3, ptr addrspace(200) [[RETVAL]], align 4
// CHECK-NEXT:    br label [[RETURN]]
// CHECK:       sw.bb4:
// CHECK-NEXT:    store i32 4, ptr addrspace(200) [[RETVAL]], align 4
// CHECK-NEXT:    br label [[RETURN]]
// CHECK:       sw.default:
// CHECK-NEXT:    store i32 -1, ptr addrspace(200) [[RETVAL]], align 4
// CHECK-NEXT:    br label [[RETURN]]
// CHECK:       return:
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr addrspace(200) [[RETVAL]], align 4
// CHECK-NEXT:    ret i32 [[TMP2]]
//
// CHECK-OPT-LABEL: @z_fixed_offset(
// CHECK-OPT-NEXT:  entry:
// CHECK-OPT-NEXT:    [[TMP0:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.offset.set.i64(ptr addrspace(200) nonnull @buf, i64 4)
// CHECK-OPT-NEXT:    [[INTCAP_VADDR:%.*]] = tail call i64 @llvm.cheri.cap.address.get.i64(ptr addrspace(200) [[TMP0]])
// CHECK-OPT-NEXT:    switch i64 [[INTCAP_VADDR]], label [[SW_DEFAULT:%.*]] [
// CHECK-OPT-NEXT:    i64 0, label [[CLEANUP:%.*]]
// CHECK-OPT-NEXT:    i64 1, label [[SW_BB1:%.*]]
// CHECK-OPT-NEXT:    i64 2, label [[SW_BB2:%.*]]
// CHECK-OPT-NEXT:    i64 3, label [[SW_BB3:%.*]]
// CHECK-OPT-NEXT:    i64 4, label [[SW_BB4:%.*]]
// CHECK-OPT-NEXT:    ]
// CHECK-OPT:       sw.bb1:
// CHECK-OPT-NEXT:    br label [[CLEANUP]]
// CHECK-OPT:       sw.bb2:
// CHECK-OPT-NEXT:    br label [[CLEANUP]]
// CHECK-OPT:       sw.bb3:
// CHECK-OPT-NEXT:    br label [[CLEANUP]]
// CHECK-OPT:       sw.bb4:
// CHECK-OPT-NEXT:    br label [[CLEANUP]]
// CHECK-OPT:       sw.default:
// CHECK-OPT-NEXT:    br label [[CLEANUP]]
// CHECK-OPT:       cleanup:
// CHECK-OPT-NEXT:    [[RETVAL_0:%.*]] = phi i32 [ -1, [[SW_DEFAULT]] ], [ 4, [[SW_BB4]] ], [ 3, [[SW_BB3]] ], [ 2, [[SW_BB2]] ], [ 1, [[SW_BB1]] ], [ 0, [[ENTRY:%.*]] ]
// CHECK-OPT-NEXT:    ret i32 [[RETVAL_0]]
//
int z_fixed_offset(void) {
  // Offset is known, so this could be optimized to a base.get and the case statements get adjusted
  // This was the previous behaviour when using separate base.get and offset.get intrinsics, but I'm not sure it makes sense to keep it.

  const char* switchval = __builtin_cheri_offset_set(buf, 4);
  switch ((__intcap_t)switchval) {
    case 0: return 0;
    case 1: return 1;
    case 2: return 2;
    case 3: return 3;
    case 4: return 4;
    default: return -1;
  }
}

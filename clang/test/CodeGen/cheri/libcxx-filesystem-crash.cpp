// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --function-signature
// REQUIRES: mips-registered-target

// This previously triggered an assert in SROA and instcombine. Now it generates
// sub-optimal code for CHERI128 but at least it doesn't crash

// RUN: %cheri128_cc1 -O2 -std=c++11 -o - -emit-llvm %s | FileCheck %s -check-prefix N64-CHERI128-IR
// RUN: %cheri128_purecap_cc1 -O2 -std=c++11 -o - -emit-llvm %s | FileCheck %s -check-prefix PURECAP-CHERI128-IR

// RUN: %cheri128_cc1 -O2 -std=c++11 -o - -S %s | FileCheck %s -check-prefixes ASM,N64-CHERI128-BAD-CODE
// RUN: %cheri128_purecap_cc1 -O2 -std=c++11 -o - -S %s | FileCheck %s -check-prefixes ASM,PURECAP-CHERI128-BAD-CODE

// std::chrono duration with __int128_t (which is what filesystem uses) was
// crashing clang. Reduced test case as follows:

template<class T>
class duration {
  T as;

public:
  template <class d> duration(d);
  T f() { return as; }
};

// IR: [[CLASS_DURATION:%class.duration]] = type { i32 }
// IR: [[CLASS_DURATION_0:%class.duration.0]] = type { i128 }

// N64-CHERI128-IR-LABEL: define {{[^@]+}}@test1
// N64-CHERI128-IR-SAME: (ptr nocapture noundef nonnull readonly align 4 dereferenceable(4) [[E:%.*]]) local_unnamed_addr #[[ATTR0:[0-9]+]] {
// N64-CHERI128-IR-NEXT:  entry:
// N64-CHERI128-IR-NEXT:    [[TMP0:%.*]] = load i32, ptr [[E]], align 4, !tbaa [[TBAA2:![0-9]+]]
// N64-CHERI128-IR-NEXT:    ret i32 [[TMP0]]
//
// PURECAP-CHERI128-IR-LABEL: define {{[^@]+}}@test1
// PURECAP-CHERI128-IR-SAME: (ptr addrspace(200) nocapture noundef nonnull readonly align 4 dereferenceable(4) [[E:%.*]]) local_unnamed_addr addrspace(200) #[[ATTR0:[0-9]+]] {
// PURECAP-CHERI128-IR-NEXT:  entry:
// PURECAP-CHERI128-IR-NEXT:    [[TMP0:%.*]] = load i32, ptr addrspace(200) [[E]], align 4, !tbaa [[TBAA2:![0-9]+]]
// PURECAP-CHERI128-IR-NEXT:    ret i32 [[TMP0]]
//
extern "C" int test1(duration<int> &e) {
  return duration<int>(e).f();
  // ASM-LABEL: test1:
  // PURECAP-ASM:       clw $2, $zero, 0($c3)
  // PURECAP-ASM-NEXT:  cjr $c17
  // PURECAP-ASM-NEXT:  nop
  // N64-ASM:       lw $2, 0($4)
  // N64-ASM-NEXT:  jr $ra
  // N64-ASM-NEXT:  nop
  // ASM: .end test1
}

// For CHERI128 some optimization attempts to replace the memcpy with an i8 addrspace(200) load/store
// While this often can make sense, it causes errors here.

// N64-CHERI128-IR-LABEL: define {{[^@]+}}@test2
// N64-CHERI128-IR-SAME: (ptr nocapture noundef nonnull readonly align 16 dereferenceable(16) [[E:%.*]]) local_unnamed_addr #[[ATTR0]] {
// N64-CHERI128-IR-NEXT:  entry:
// N64-CHERI128-IR-NEXT:    [[REF_TMP_SROA_0:%.*]] = alloca i128, align 16
// N64-CHERI128-IR-NEXT:    call void @llvm.lifetime.start.p0(i64 16, ptr nonnull [[REF_TMP_SROA_0]])
// N64-CHERI128-IR-NEXT:    [[TMP0:%.*]] = load ptr addrspace(200), ptr [[E]], align 16, !tbaa [[TBAA6:![0-9]+]]
// N64-CHERI128-IR-NEXT:    store ptr addrspace(200) [[TMP0]], ptr [[REF_TMP_SROA_0]], align 16, !tbaa [[TBAA6]]
// N64-CHERI128-IR-NEXT:    [[REF_TMP_SROA_0_0_REF_TMP_SROA_0_0_REF_TMP_SROA_0_0_:%.*]] = load i128, ptr [[REF_TMP_SROA_0]], align 16, !tbaa [[TBAA8:![0-9]+]]
// N64-CHERI128-IR-NEXT:    call void @llvm.lifetime.end.p0(i64 16, ptr nonnull [[REF_TMP_SROA_0]])
// N64-CHERI128-IR-NEXT:    ret i128 [[REF_TMP_SROA_0_0_REF_TMP_SROA_0_0_REF_TMP_SROA_0_0_]]
//
// PURECAP-CHERI128-IR-LABEL: define {{[^@]+}}@test2
// PURECAP-CHERI128-IR-SAME: (ptr addrspace(200) nocapture noundef nonnull readonly align 16 dereferenceable(16) [[E:%.*]]) local_unnamed_addr addrspace(200) #[[ATTR0]] {
// PURECAP-CHERI128-IR-NEXT:  entry:
// PURECAP-CHERI128-IR-NEXT:    [[REF_TMP_SROA_0:%.*]] = alloca i128, align 16, addrspace(200)
// PURECAP-CHERI128-IR-NEXT:    call void @llvm.lifetime.start.p200(i64 16, ptr addrspace(200) nonnull [[REF_TMP_SROA_0]])
// PURECAP-CHERI128-IR-NEXT:    [[TMP0:%.*]] = load ptr addrspace(200), ptr addrspace(200) [[E]], align 16, !tbaa [[TBAA6:![0-9]+]]
// PURECAP-CHERI128-IR-NEXT:    store ptr addrspace(200) [[TMP0]], ptr addrspace(200) [[REF_TMP_SROA_0]], align 16, !tbaa [[TBAA6]]
// PURECAP-CHERI128-IR-NEXT:    [[REF_TMP_SROA_0_0_REF_TMP_SROA_0_0_REF_TMP_SROA_0_0_:%.*]] = load i128, ptr addrspace(200) [[REF_TMP_SROA_0]], align 16, !tbaa [[TBAA8:![0-9]+]]
// PURECAP-CHERI128-IR-NEXT:    call void @llvm.lifetime.end.p200(i64 16, ptr addrspace(200) nonnull [[REF_TMP_SROA_0]])
// PURECAP-CHERI128-IR-NEXT:    ret i128 [[REF_TMP_SROA_0_0_REF_TMP_SROA_0_0_REF_TMP_SROA_0_0_]]
//
extern "C" __int128 test2(duration<__int128_t> &e) {
  return duration<__int128_t>(e).f();
  // ASM-LABEL: test2:
  // ASM:       .set noat
  // ASM:       # %bb.0: # %entry
  // Currently we spill to the stack and reload for CHERI128
  // PURECAP-ASM-NEXT:       cld $2, $zero, 0($c3)
  // PURECAP-ASM-NEXT:  cld $3, $zero, 8($c3)
  // PURECAP-ASM-NEXT:  cjr $c17
  // PURECAP-ASM-NEXT:  nop

  // PURECAP-CHERI128-BAD-CODE-NEXT: cincoffset $c11, $c11, -16
  // PURECAP-CHERI128-BAD-CODE-NEXT: clc $c1, $zero, 0($c3)
  // PURECAP-CHERI128-BAD-CODE-NEXT: csc $c1, $zero, 0($c11)
  // PURECAP-CHERI128-BAD-CODE-NEXT: cld $3, $zero, 8($c11)
  // PURECAP-CHERI128-BAD-CODE-NEXT: cld $2, $zero, 0($c11)
  // PURECAP-CHERI128-BAD-CODE-NEXT: cjr $c17
  // PURECAP-CHERI128-BAD-CODE-NEXT: cincoffset $c11, $c11, 16

  // N64-ASM-NEXT:  ld $2, 0($4)
  // N64-ASM-NEXT:  ld $3, 8($4)
  // N64-ASM-NEXT:  jr $ra
  // N64-ASM-NEXT:  nop
  // N64-CHERI128-BAD-CODE-NEXT: daddiu	$sp, $sp, -16
  // N64-CHERI128-BAD-CODE-NEXT: clc	$c1, $4, 0($ddc)
  // N64-CHERI128-BAD-CODE-NEXT: daddiu	$1, $sp, 0
  // N64-CHERI128-BAD-CODE-NEXT: csc	$c1, $1, 0($ddc)
  // N64-CHERI128-BAD-CODE-NEXT: ld $2, 0($sp)
  // N64-CHERI128-BAD-CODE-NEXT: ld $3, 8($sp)
  // N64-CHERI128-BAD-CODE-NEXT: jr $ra
  // N64-CHERI128-BAD-CODE-NEXT: daddiu $sp, $sp, 16
  // ASM:       .end test2
}

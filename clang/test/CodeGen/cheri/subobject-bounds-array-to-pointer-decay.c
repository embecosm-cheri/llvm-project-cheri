// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %cheri_purecap_cc1 -cheri-bounds=subobject-safe -O2 -emit-llvm %s -o - -Rcheri-subobject-bounds -mllvm -debug-only="cheri-bounds" -verify | %cheri_FileCheck %s
// RUN: %cheri_purecap_cc1 -cheri-bounds=subobject-safe -O0 -emit-llvm %s -o /dev/null -w -mllvm -stats 2>&1 | FileCheck %s -check-prefix DBG -implicit-check-not cheri-bounds
// DBG: ... Statistics Collected ...
// DBG:  9 cheri-bounds - Number of array-to-pointer-decays checked for tightening bounds
// DBG:  4 cheri-bounds - Number of array-to-pointer-decays where remaining allocation size was used
// DBG:  5 cheri-bounds - Number of array-to-pointer-decays where bounds were tightened
// REQUIRES: asserts

void overflow_buffer(void *);

typedef struct {
  long x;
  int buf[10];
  char c;
} struct_with_array;

// NOTE: bounds must be set before the GEP:
// CHECK-LABEL: @test_struct_member_decay(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[BUF:%.*]] = getelementptr inbounds [[STRUCT_STRUCT_WITH_ARRAY:%.*]], ptr addrspace(200) [[S:%.*]], i64 0, i32 1
// CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) nonnull [[BUF]], i64 40)
// CHECK-NEXT:    tail call void @overflow_buffer(ptr addrspace(200) noundef [[TMP0]]) #[[ATTR5:[0-9]+]]
// CHECK-NEXT:    ret void
//
void test_struct_member_decay(struct_with_array *s, long index) {
  // should set bounds to 10
  overflow_buffer(s->buf); // expected-remark{{setting sub-object bounds for field 'buf' (array decay on 'int[10]') to 40 bytes}}
}

// CHECK-LABEL: @test_local_array_decay(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[BUFFER:%.*]] = alloca [12 x i32], align 4, addrspace(200)
// CHECK-NEXT:    call void @llvm.lifetime.start.p200(i64 48, ptr addrspace(200) nonnull [[BUFFER]]) #[[ATTR5]]
// CHECK-NEXT:    [[TMP0:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) nonnull [[BUFFER]], i64 48)
// CHECK-NEXT:    call void @overflow_buffer(ptr addrspace(200) noundef [[TMP0]]) #[[ATTR5]]
// CHECK-NEXT:    call void @llvm.lifetime.end.p200(i64 48, ptr addrspace(200) nonnull [[BUFFER]]) #[[ATTR5]]
// CHECK-NEXT:    ret void
//
void test_local_array_decay(struct_with_array *s, long index) {
  int buffer[12];
  // should set bounds to 10
  overflow_buffer(buffer); // expected-remark{{setting bounds for array decay on 'int[12]' to 48 bytes}}
}

// CHECK-LABEL: @return_stack_decay(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[BUFFER:%.*]] = alloca [21 x i32], align 4, addrspace(200)
// CHECK-NEXT:    call void @llvm.lifetime.start.p200(i64 84, ptr addrspace(200) nonnull [[BUFFER]]) #[[ATTR5]]
// CHECK-NEXT:    [[TMP0:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) nonnull [[BUFFER]], i64 84)
// CHECK-NEXT:    call void @llvm.lifetime.end.p200(i64 84, ptr addrspace(200) nonnull [[BUFFER]]) #[[ATTR5]]
// CHECK-NEXT:    ret ptr addrspace(200) [[TMP0]]
//
void* return_stack_decay(struct_with_array *s, long index) {
  int buffer[21];
  return buffer; // expected-remark{{setting bounds for array decay on 'int[21]' to 84 bytes}}
  // expected-warning@-1{{address of stack memory associated with local variable 'buffer' returned}}
}

float global_buffer[100];
// CHECK-LABEL: @test_global_array_decay(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) nonnull @global_buffer, i64 400)
// CHECK-NEXT:    tail call void @overflow_buffer(ptr addrspace(200) noundef [[TMP0]]) #[[ATTR5]]
// CHECK-NEXT:    ret void
//
void test_global_array_decay(long index) {
  // should set bounds to 100 * 4
  overflow_buffer(global_buffer); // expected-remark{{setting bounds for array decay on 'float[100]' to 400 bytes}}
}

struct foo {
  int buffer[1];
  char buffer2;
} global_foo;

// CHECK-LABEL: @test_global_struct_array_decay(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) nonnull @global_foo, i64 4)
// CHECK-NEXT:    tail call void @overflow_buffer(ptr addrspace(200) noundef [[TMP0]]) #[[ATTR5]]
// CHECK-NEXT:    ret void
//
void test_global_struct_array_decay(struct_with_array *s, long index) {
  overflow_buffer(global_foo.buffer); // expected-remark{{setting sub-object bounds for field 'buffer' (array decay on 'int[1]') to 4 bytes}}
}

// CHECK-LABEL: @test_local_vla_decay(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[VLA:%.*]] = alloca i32, i64 [[SIZE:%.*]], align 4, addrspace(200)
// CHECK-NEXT:    [[CUR_OFFSET:%.*]] = call i64 @llvm.cheri.cap.offset.get.i64(ptr addrspace(200) nonnull [[VLA]])
// CHECK-NEXT:    [[CUR_LEN:%.*]] = call i64 @llvm.cheri.cap.length.get.i64(ptr addrspace(200) nonnull [[VLA]])
// CHECK-NEXT:    [[REMAINING_BYTES:%.*]] = sub i64 [[CUR_LEN]], [[CUR_OFFSET]]
// CHECK-NEXT:    [[TMP0:%.*]] = call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) nonnull [[VLA]], i64 [[REMAINING_BYTES]])
// CHECK-NEXT:    call void @overflow_buffer(ptr addrspace(200) noundef [[TMP0]]) #[[ATTR5]]
// CHECK-NEXT:    ret void
//
void test_local_vla_decay(struct_with_array *s, long size) {
  // TODO: should not set bounds here since the backend will bound the VLA
  int vla[size];
  overflow_buffer(vla); // expected-remark{{setting bounds for array decay on 'int[size]' to remaining bytes (array decay on variable size type)}}
}

struct vla_struct {
  char len;
  int vla[];
};

// CHECK-LABEL: @test_vla_struct_member_decay(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[VLA:%.*]] = getelementptr inbounds [[STRUCT_VLA_STRUCT:%.*]], ptr addrspace(200) [[S:%.*]], i64 0, i32 1
// CHECK-NEXT:    [[CUR_OFFSET:%.*]] = tail call i64 @llvm.cheri.cap.offset.get.i64(ptr addrspace(200) nonnull [[VLA]])
// CHECK-NEXT:    [[CUR_LEN:%.*]] = tail call i64 @llvm.cheri.cap.length.get.i64(ptr addrspace(200) nonnull [[VLA]])
// CHECK-NEXT:    [[REMAINING_BYTES:%.*]] = sub i64 [[CUR_LEN]], [[CUR_OFFSET]]
// CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) nonnull [[VLA]], i64 [[REMAINING_BYTES]])
// CHECK-NEXT:    tail call void @overflow_buffer(ptr addrspace(200) noundef [[TMP0]]) #[[ATTR5]]
// CHECK-NEXT:    ret void
//
void test_vla_struct_member_decay(struct vla_struct *s, long index) {
  overflow_buffer(s->vla); // expected-remark{{setting sub-object bounds for field 'vla' (array decay on 'int[]') to remaining bytes (member is potential variable length array)}}
}

struct fake_vla_struct {
  char len;
  int fake_vla[0];
};

// CHECK-LABEL: @test_fake_vla_struct_member_decay(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[FAKE_VLA:%.*]] = getelementptr inbounds [[STRUCT_FAKE_VLA_STRUCT:%.*]], ptr addrspace(200) [[S:%.*]], i64 0, i32 1
// CHECK-NEXT:    [[CUR_OFFSET:%.*]] = tail call i64 @llvm.cheri.cap.offset.get.i64(ptr addrspace(200) nonnull [[FAKE_VLA]])
// CHECK-NEXT:    [[CUR_LEN:%.*]] = tail call i64 @llvm.cheri.cap.length.get.i64(ptr addrspace(200) nonnull [[FAKE_VLA]])
// CHECK-NEXT:    [[REMAINING_BYTES:%.*]] = sub i64 [[CUR_LEN]], [[CUR_OFFSET]]
// CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) nonnull [[FAKE_VLA]], i64 [[REMAINING_BYTES]])
// CHECK-NEXT:    tail call void @overflow_buffer(ptr addrspace(200) noundef [[TMP0]]) #[[ATTR5]]
// CHECK-NEXT:    ret void
//
void test_fake_vla_struct_member_decay(struct fake_vla_struct *s, long index) {
  overflow_buffer(s->fake_vla); // expected-remark{{setting sub-object bounds for field 'fake_vla' (array decay on 'int[0]') to remaining bytes (member is potential variable length array)}}
}

struct fake_vla_struct2 {
  char len;
  int fake_vla2[1]; // last member, size==1 -> possible fake VLA
};

// CHECK-LABEL: @test_fake_vla_struct2_member_decay(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[FAKE_VLA2:%.*]] = getelementptr inbounds [[STRUCT_FAKE_VLA_STRUCT2:%.*]], ptr addrspace(200) [[S:%.*]], i64 0, i32 1
// CHECK-NEXT:    [[CUR_OFFSET:%.*]] = tail call i64 @llvm.cheri.cap.offset.get.i64(ptr addrspace(200) nonnull [[FAKE_VLA2]])
// CHECK-NEXT:    [[CUR_LEN:%.*]] = tail call i64 @llvm.cheri.cap.length.get.i64(ptr addrspace(200) nonnull [[FAKE_VLA2]])
// CHECK-NEXT:    [[REMAINING_BYTES:%.*]] = sub i64 [[CUR_LEN]], [[CUR_OFFSET]]
// CHECK-NEXT:    [[TMP0:%.*]] = tail call ptr addrspace(200) @llvm.cheri.cap.bounds.set.i64(ptr addrspace(200) nonnull [[FAKE_VLA2]], i64 [[REMAINING_BYTES]])
// CHECK-NEXT:    tail call void @overflow_buffer(ptr addrspace(200) noundef [[TMP0]]) #[[ATTR5]]
// CHECK-NEXT:    ret void
//
void test_fake_vla_struct2_member_decay(struct fake_vla_struct2 *s, long index) {
  // TODO: should set reverse bounds here: raise bottom to current offset
  overflow_buffer(s->fake_vla2); // expected-remark{{setting sub-object bounds for field 'fake_vla2' (array decay on 'int[1]') to remaining bytes (member is potential variable length array)}}
}

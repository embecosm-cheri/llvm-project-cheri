// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %cheri_cc1 -o - -O2 -emit-llvm %s | FileCheck %s

// CHECK-LABEL: @add_invalid_ptr(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret ptr addrspace(200) getelementptr inbounds (i8, ptr addrspace(200) inttoptr (i64 100 to ptr addrspace(200)), i64 924)
//
void *__capability add_invalid_ptr(void) {
  // This cannot return a valid tagged capability:
  char* __capability cap = (char* __capability)100;
  cap += 10;
  return cap + 914;
}

// CHECK-LABEL: @add_valid_ptr(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret ptr addrspace(200) getelementptr inbounds (i8, ptr addrspace(200) addrspacecast (ptr inttoptr (i64 100 to ptr) to ptr addrspace(200)), i64 924)
//
void *__capability add_valid_ptr(void) {
  // This can return a valid tagged capability:
  char *__capability cap = (__cheri_tocap char *__capability)(char *)100;
  cap += 10;
  return cap + 914;
}

// CHECK-LABEL: @add_uintcap_t(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret ptr addrspace(200) getelementptr (i8, ptr addrspace(200) null, i64 1024)
//
__uintcap_t add_uintcap_t(void) {
  // This always returns a untagged capability with offset 1024
  __uintcap_t cap = (__uintcap_t)100;
  cap += 10;
  return cap + 914;
}

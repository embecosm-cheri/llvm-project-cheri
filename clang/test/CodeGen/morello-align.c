// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %clang_cc1 -triple aarch64-none-elf -target-feature +morello -target-feature +c64 -target-abi purecap -O1 %s -emit-llvm -o - | FileCheck %s

// CHECK-LABEL: @foo(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[PTRADDR:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[A:%.*]])
// CHECK-NEXT:    [[TMP0:%.*]] = and i64 [[PTRADDR]], 3
// CHECK-NEXT:    [[DIFF:%.*]] = sub nsw i64 0, [[TMP0]]
// CHECK-NEXT:    [[ALIGNED_RESULT:%.*]] = getelementptr inbounds i8, i8 addrspace(200)* [[A]], i64 [[DIFF]]
// CHECK-NEXT:    [[PTRINT:%.*]] = ptrtoint i8 addrspace(200)* [[ALIGNED_RESULT]] to i64
// CHECK-NEXT:    [[MASKEDPTR:%.*]] = and i64 [[PTRINT]], 3
// CHECK-NEXT:    [[MASKCOND:%.*]] = icmp eq i64 [[MASKEDPTR]], 0
// CHECK-NEXT:    call void @llvm.assume(i1 [[MASKCOND]])
// CHECK-NEXT:    ret i8 addrspace(200)* [[ALIGNED_RESULT]]
//
void *foo(void * a) {
  return __builtin_align_down(a, 4);
}

// CHECK-LABEL: @bar(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[PTRADDR:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[A:%.*]])
// CHECK-NEXT:    [[OVER_BOUNDARY:%.*]] = add i64 [[PTRADDR]], 3
// CHECK-NEXT:    [[ALIGNED_INTPTR:%.*]] = and i64 [[OVER_BOUNDARY]], -4
// CHECK-NEXT:    [[DIFF:%.*]] = sub i64 [[ALIGNED_INTPTR]], [[PTRADDR]]
// CHECK-NEXT:    [[ALIGNED_RESULT:%.*]] = getelementptr inbounds i8, i8 addrspace(200)* [[A]], i64 [[DIFF]]
// CHECK-NEXT:    [[PTRINT:%.*]] = ptrtoint i8 addrspace(200)* [[ALIGNED_RESULT]] to i64
// CHECK-NEXT:    [[MASKEDPTR:%.*]] = and i64 [[PTRINT]], 3
// CHECK-NEXT:    [[MASKCOND:%.*]] = icmp eq i64 [[MASKEDPTR]], 0
// CHECK-NEXT:    call void @llvm.assume(i1 [[MASKCOND]])
// CHECK-NEXT:    ret i8 addrspace(200)* [[ALIGNED_RESULT]]
//
void *bar(void * a) {
  return __builtin_align_up(a, 4);
}

// CHECK-LABEL: @baz(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[PTRADDR:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[A:%.*]])
// CHECK-NEXT:    [[OVER_BOUNDARY:%.*]] = add i64 [[PTRADDR]], 3
// CHECK-NEXT:    [[ALIGNED_INTPTR:%.*]] = and i64 [[OVER_BOUNDARY]], -4
// CHECK-NEXT:    [[DIFF:%.*]] = sub i64 [[ALIGNED_INTPTR]], [[PTRADDR]]
// CHECK-NEXT:    [[ALIGNED_RESULT:%.*]] = getelementptr inbounds i8, i8 addrspace(200)* [[A]], i64 [[DIFF]]
// CHECK-NEXT:    [[PTRINT:%.*]] = ptrtoint i8 addrspace(200)* [[ALIGNED_RESULT]] to i64
// CHECK-NEXT:    [[MASKEDPTR:%.*]] = and i64 [[PTRINT]], 3
// CHECK-NEXT:    [[MASKCOND:%.*]] = icmp eq i64 [[MASKEDPTR]], 0
// CHECK-NEXT:    call void @llvm.assume(i1 [[MASKCOND]])
// CHECK-NEXT:    ret i8 addrspace(200)* [[ALIGNED_RESULT]]
//
void *baz(void * a) {
  a = __builtin_align_up(a, 4);
  a = __builtin_align_up(a, 2);
  return a;
}

// CHECK-LABEL: @bat(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[X:%.*]])
// CHECK-NEXT:    [[AND:%.*]] = and i64 [[TMP0]], -4
// CHECK-NEXT:    [[TMP1:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.address.set.i64(i8 addrspace(200)* [[X]], i64 [[AND]])
// CHECK-NEXT:    ret i8 addrspace(200)* [[TMP1]]
//
__uintcap_t bat(__uintcap_t x) {
  return x & ~0x3;
}

// CHECK-LABEL: @fib(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = getelementptr i8, i8 addrspace(200)* [[X:%.*]], i64 3
// CHECK-NEXT:    [[TMP1:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[TMP0]])
// CHECK-NEXT:    [[AND:%.*]] = and i64 [[TMP1]], -4
// CHECK-NEXT:    [[TMP2:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.address.set.i64(i8 addrspace(200)* [[X]], i64 [[AND]])
// CHECK-NEXT:    ret i8 addrspace(200)* [[TMP2]]
//
__uintcap_t fib(__uintcap_t x) {
  return (x + 0x3) & ~0x3;
}
// CHECK-LABEL: @fib2(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = call i64 @llvm.cheri.cap.address.get.i64(i8 addrspace(200)* [[X:%.*]])
// CHECK-NEXT:    [[ADD:%.*]] = add i64 [[TMP0]], 3
// CHECK-NEXT:    [[AND:%.*]] = and i64 [[ADD]], -4
// CHECK-NEXT:    [[TMP1:%.*]] = call i8 addrspace(200)* @llvm.cheri.cap.address.set.i64(i8 addrspace(200)* [[X]], i64 [[AND]])
// CHECK-NEXT:    ret i8 addrspace(200)* [[TMP1]]
//
__uintcap_t fib2(__uintcap_t x) {
  return ((x - 1) + 0x4) & ~0x3;
}

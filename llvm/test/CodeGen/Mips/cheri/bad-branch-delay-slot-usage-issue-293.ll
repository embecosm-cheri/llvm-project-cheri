; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: %cheri_llc -o - -O2 %s | FileCheck %s
; https://github.com/CTSRD-CHERI/llvm-project/issues/293

; TODO: the CHERI loop could be slightly more efficient by moving the subtract in the delay slot
; Generated from this source code:
; void doLoop_cap(char * __capability in, char * __capability out, int i) {
;   do {
;     out[i]=in[i];
;   } while (i--);
; }
;
; void doLoop_ptr(char * in, char * out, int i) {
;   do {
;     out[i]=in[i];
;   } while (i--);
; }


; Function Attrs: norecurse nounwind
define void @doLoop_cap(i8 addrspace(200)* nocapture readonly %in, i8 addrspace(200)* nocapture %out, i32 signext %i) local_unnamed_addr norecurse nounwind {
; CHECK-LABEL: doLoop_cap:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    daddiu $2, $zero, -1
; CHECK-NEXT:  .LBB0_1: # %do.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    clb $1, $4, 0($c3)
; CHECK-NEXT:    csb $1, $4, 0($c4)
; CHECK-NEXT:    daddiu $4, $4, -1
; CHECK-NEXT:    bne $4, $2, .LBB0_1
; CHECK-NEXT:    nop
; CHECK-NEXT:  # %bb.2: # %do.end
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    nop
entry:
  %0 = sext i32 %i to i64
  br label %do.body

do.body:                                          ; preds = %do.body, %entry
  %indvars.iv = phi i64 [ %indvars.iv.next, %do.body ], [ %0, %entry ]
  %arrayidx = getelementptr inbounds i8, i8 addrspace(200)* %in, i64 %indvars.iv
  %1 = load i8, i8 addrspace(200)* %arrayidx, align 1
  %arrayidx2 = getelementptr inbounds i8, i8 addrspace(200)* %out, i64 %indvars.iv
  store i8 %1, i8 addrspace(200)* %arrayidx2, align 1
  %indvars.iv.next = add nsw i64 %indvars.iv, -1
  %2 = icmp eq i64 %indvars.iv, 0
  br i1 %2, label %do.end, label %do.body

do.end:                                           ; preds = %do.body
  ret void
}

; Function Attrs: norecurse nounwind
define void @doLoop_ptr(i8* nocapture readonly %in, i8* nocapture %out, i32 signext %i) local_unnamed_addr norecurse nounwind {
; CHECK-LABEL: doLoop_ptr:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    daddiu $2, $zero, -1
; CHECK-NEXT:  .LBB1_1: # %do.body
; CHECK-NEXT:    # =>This Inner Loop Header: Depth=1
; CHECK-NEXT:    daddu $1, $4, $6
; CHECK-NEXT:    lb $1, 0($1)
; CHECK-NEXT:    daddu $3, $5, $6
; CHECK-NEXT:    daddiu $6, $6, -1
; CHECK-NEXT:    bne $6, $2, .LBB1_1
; CHECK-NEXT:    sb $1, 0($3)
; CHECK-NEXT:  # %bb.2: # %do.end
; CHECK-NEXT:    jr $ra
; CHECK-NEXT:    nop
entry:
  %0 = sext i32 %i to i64
  br label %do.body

do.body:                                          ; preds = %do.body, %entry
  %indvars.iv = phi i64 [ %indvars.iv.next, %do.body ], [ %0, %entry ]
  %arrayidx = getelementptr inbounds i8, i8* %in, i64 %indvars.iv
  %1 = load i8, i8* %arrayidx, align 1
  %arrayidx2 = getelementptr inbounds i8, i8* %out, i64 %indvars.iv
  store i8 %1, i8* %arrayidx2, align 1
  %indvars.iv.next = add nsw i64 %indvars.iv, -1
  %2 = icmp eq i64 %indvars.iv, 0
  br i1 %2, label %do.end, label %do.body

do.end:                                           ; preds = %do.body
  ret void
}
